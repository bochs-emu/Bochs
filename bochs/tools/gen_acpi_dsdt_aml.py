#!/usr/bin/env python3
"""Generate bochs/iodev/acpi_dsdt_aml.h from bochs/bios/acpi-dsdt.dsl.

This is a developer convenience script to keep the embedded DSDT AML blob
reproducible without adding a build-time dependency on ACPICA iasl.

Usage:
  python bochs/tools/gen_acpi_dsdt_aml.py --bochs-root E:/tmp/bochs_upstream/bochs

Requires:
  - iasl available on PATH, or pass --iasl "path/to/iasl.exe"

What it does:
  - Runs: iasl -tc -p <outprefix> <dsl>
  - Extracts the AmlCode[] initializer from the generated .c
  - Writes: bochs/iodev/acpi_dsdt_aml.h (LF endings)
"""

from __future__ import annotations

import argparse
import os
import re
import subprocess
import sys
from pathlib import Path


_AML_RE = re.compile(
    r"unsigned\s+char\s+AmlCode\s*\[\s*\]\s*=\s*\{(?P<body>.*?)\};",
    re.DOTALL,
)


def _run(cmd: list[str], cwd: Path) -> None:
    proc = subprocess.run(cmd, cwd=str(cwd), capture_output=True, text=True)
    if proc.returncode != 0:
        raise RuntimeError(
            "Command failed:\n"
            f"  cmd: {' '.join(cmd)}\n"
            f"  cwd: {cwd}\n"
            f"  stdout:\n{proc.stdout}\n"
            f"  stderr:\n{proc.stderr}\n"
        )


def _extract_amlcode_c_array(c_text: str) -> str:
    m = _AML_RE.search(c_text)
    if not m:
        raise RuntimeError("Could not find unsigned char AmlCode[] initializer in iasl C output")

    body = m.group("body").strip()
    # Normalize whitespace: keep commas, collapse runs of whitespace, and split into lines.
    # iasl already formats reasonably; we just trim trailing spaces.
    lines = [ln.rstrip() for ln in body.splitlines()]
    return "\n".join(lines).strip() + "\n"


def _write_header(out_h: Path, aml_body: str, source_dsl: Path) -> None:
    header = f"""/*
 * GENERATED FILE - DO NOT EDIT.
 *
 * This header embeds the compiled AML for the Bochs DSDT.
 * Source: {source_dsl.as_posix()}
 *
 * Generated by: bochs/tools/gen_acpi_dsdt_aml.py
 */
#ifndef __ACPI_DSDT_AML_H__
#define __ACPI_DSDT_AML_H__

const unsigned char AmlCode[] =
{{
{aml_body}}};

#endif
"""

    # Enforce LF regardless of platform.
    out_h.write_text(header.replace("\r\n", "\n"), encoding="utf-8", newline="\n")


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--bochs-root",
        type=Path,
        required=True,
        help="Path to the 'bochs' source root (the folder containing bios/, iodev/, etc)",
    )
    ap.add_argument(
        "--iasl",
        type=str,
        default="iasl",
        help="iasl executable (default: iasl on PATH)",
    )
    args = ap.parse_args(argv)

    bochs_root: Path = args.bochs_root
    dsl = bochs_root / "bios" / "acpi-dsdt.dsl"
    out_h = bochs_root / "iodev" / "acpi_dsdt_aml.h"

    if not dsl.exists():
        ap.error(f"DSL not found: {dsl}")

    # Build output in a temp-ish location within bochs_root to keep paths simple on Windows.
    outprefix = bochs_root / "tools" / "_acpi_dsdt_aml"
    out_c = Path(str(outprefix) + ".c")

    # Remove old output if present.
    for p in [out_c, Path(str(outprefix) + ".aml"), Path(str(outprefix) + ".lst")]:
        try:
            p.unlink()
        except FileNotFoundError:
            pass

    _run([args.iasl, "-tc", "-p", str(outprefix), str(dsl)], cwd=bochs_root)

    if not out_c.exists():
        raise RuntimeError(f"iasl did not produce expected C file: {out_c}")

    c_text = out_c.read_text(encoding="utf-8", errors="replace")
    aml_body = _extract_amlcode_c_array(c_text)
    _write_header(out_h, aml_body, dsl)

    print(f"Wrote {out_h}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
