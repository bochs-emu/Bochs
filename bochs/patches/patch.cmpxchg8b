Date: 15 Nov 2001 17:41:33 +0100
From: Michael Hohmuth <hohmuth@innocent.com>
To: bochs-developers@lists.sourceforge.net
Subject: [Bochs-developers] Patch: CMPXCHG8B
Parts/Attachments:
1 Shown    19 lines  Text
2   OK     59 lines  Text
----------------------------------------

Bochs developers,

attached below is a patch to add support for the CMPXCHG8B instruction
to Bochs.  The patch is relative to the 20011008 snapshot release.  I
have tested the modification, and it seems to work fine.

One question:

I mostly adapted the code from the implementation of CMPXCHG,
implemented in BX_CPU_C::CMPXCHG_EdGd().  Could someone please explain
what the line containing ``SET_FLAGS_OSZAPC_32'' does in that
function, and whether something similar is needed for CMPXCHG8B?

Cheers,
Michael
-- 
hohmuth@innocent.com, hohmuth@inf.tu-dresden.de
http://home.pages.de/~hohmuth/


Index: arith32.cc
===================================================================
RCS file: /home/hohmuth/local/var/cvs/bochs/cpu/arith32.cc,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -r1.1.1.1 -r1.2
--- arith32.cc	2001/11/14 17:26:46	1.1.1.1
+++ arith32.cc	2001/11/15 16:10:09	1.2
@@ -1,5 +1,5 @@
 /////////////////////////////////////////////////////////////////////////
-// $Id: patch.cmpxchg8b,v 1.1 2001-11-15 16:53:24 bdenney Exp $
+// $Id: patch.cmpxchg8b,v 1.1 2001-11-15 16:53:24 bdenney Exp $
 /////////////////////////////////////////////////////////////////////////
 //
 //  Copyright (C) 2001  MandrakeSoft S.A.
@@ -856,11 +856,38 @@ BX_CPU_C::CMPXCHG_EdGd(BxInstruction_t *
 BX_CPU_C::CMPXCHG8B(BxInstruction_t *i)
 {
 #if (BX_CPU_LEVEL >= 5) || (BX_CPU_LEVEL_HACKED >= 5)
-  if (i->mod != 0xc0) {
-    BX_INFO(("CMPXCHG8B: dest is reg: #UD"));
-    UndefinedOpcode(i);
-    }
-  BX_PANIC(("CMPXCHG8B: not implemented yet"));
+
+    Bit32u op1_64_lo, op1_64_hi, diff;
+
+    if (i->mod == 0xc0) {
+      BX_INFO(("CMPXCHG8B: dest is reg: #UD"));
+      UndefinedOpcode(i);
+      }
+
+    /* pointer, segment address pair */
+    read_virtual_dword(i->seg, i->rm_addr, &op1_64_lo);
+    read_RMW_virtual_dword(i->seg, i->rm_addr + 4, &op1_64_hi);
+
+    diff = EAX - op1_64_lo;
+    diff |= EDX - op1_64_hi;
+
+//     SET_FLAGS_OSZAPC_32(EAX, op1_32, diff_32, BX_INSTR_CMP32);
+
+    if (diff == 0) {  // if accumulator == dest
+      // ZF = 1
+      set_ZF(1);
+      // dest <-- src
+      write_RMW_virtual_dword(ECX);
+      write_virtual_dword(i->seg, i->rm_addr, &EBX);
+      }
+    else {
+      // ZF = 0
+      set_ZF(0);
+      // accumulator <-- dest
+      EAX = op1_64_lo;
+      EDX = op1_64_hi;
+      }
+  
 #else
   BX_INFO(("CMPXCHG8B: not implemented yet"));
   UndefinedOpcode(i);
