----------------------------------------------------------------------
Patch name: patch.fdc-read-check-head
Author: Bryce Denney
Date: Fri Sep 28 23:20:49 EDT 2001
RCS Id: $Id: patch.fdc-read-check-head,v 1.2 2001-09-29 03:20:47 bdenney Exp $

Detailed description:

This is intended to fix source forge bug 4339945, floppy drive read
input error checking.  The bug report was:
> When sending the read command to the floppy drive, in one parameter
> you send the drive number in bit 0, and the head number in bit 2.
> Later on in the command sequence, you send another byte with the
> head bit in bit 0. For error-free code, these two head values should
> be identical, and Bochs doesn't have problems. If they are not equal
> however, my real floppy drive will not read the disk. Status
> registers ST0, ST1, and ST2 equal 0x40, 0x04 and 0x00, respectively.
> The value of ST1 means the sector was not found. Bochs, however,
> will allow the read to go through and it returns the sector that is
> under the head given by the second time you submit the head number
> in the read sequence. 

I don't have any test code, so I'm asking the user to try it out or
provide some test code.

Patch was created with:
  cvs diff -u
Apply patch to what version:
  current cvs (9/28/2001)
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------

===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/floppy.cc,v
retrieving revision 1.20
diff -u -r1.20 floppy.cc
--- iodev/floppy.cc	2001/09/26 17:35:51	1.20
+++ iodev/floppy.cc	2001/09/29 03:19:31
@@ -735,6 +735,28 @@
       if (head > 1)
         BX_PANIC(("io: bad head #"));
 
+      // check that head number in command[1] bit two matches the head
+      // reported in the head number field.  Real floppy drives are
+      // picky about this, as reported in SF bug #439945, (Floppy drive 
+      // read input error checking).
+      if (head != (BX_FD_THIS s.command[1]>>2)&1) {
+        BX_ERROR(("head number in command[1] doesn't match head field"));
+        BX_FD_THIS s.result_size = 7;
+        BX_FD_THIS s.result_index = 0;
+        BX_FD_THIS s.result[0] = 0x40 | (BX_FD_THIS s.head[drive]<<2) | drive; // abnormal termination
+        BX_FD_THIS s.result[1] = 0x04; // 0000 0100
+        BX_FD_THIS s.result[2] = 0x00; // 0000 0000
+        BX_FD_THIS s.result[3] = BX_FD_THIS s.cylinder[drive];
+        BX_FD_THIS s.result[4] = BX_FD_THIS s.head[drive];
+        BX_FD_THIS s.result[5] = BX_FD_THIS s.sector[drive];
+        BX_FD_THIS s.result[6] = 2; // sector size = 512
+
+        BX_FD_THIS s.pending_command = 0;
+        BX_FD_THIS s.main_status_reg = FD_MS_MRQ | FD_MS_DIO | FD_MS_BUSY;
+        BX_FD_THIS devices->pic->trigger_irq(6);
+        return;
+      }
+
       if ( BX_FD_THIS s.media_present[drive] == 0 ) {
         // media not in drive, return error
 
