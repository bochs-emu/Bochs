----------------------------------------------------------------------
Patch name: patch.2hd-experimental
Author: Bryce Denney
Date: Thu May  3 11:38:16 EDT 2001

Detailed description:

THIS IS EXPERIMENTAL CODE.  Back up your disk images before trying it!

  This is a first attempt at allowing "diskd" to work.  This patch
  does the following:
  - remove panic when diskd arg is used.  Only panic if both cdromd and
    diskd are both used.
  - in harddrv.cc, when diskd is present, fill in the CMOS RAM with hard
    disk data for second drive.  
  - Added code that leans toward seconde IDE controller support, but 
    it's still commented out.  (not complete)
  - hacked rombios.c int 0x13 code, get_hd_geometry, and hard_drive_post
    which fills in the EBDA info to allow second drive
  To be done still:
  - make sure it still works with only one HD!  The harddrv.cc code should
    be okay, but the rombios.c code has some hardcoded stuff.
  - my assembly isn't that good, but try to reuse code for EBDA setup
    of hd0 and hd1.
  - test cdrom with these changes, to see if I broke it.

Apply patch to:
  current CVS sources (5/3/2001)
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
===================================================================
RCS file: /cvsroot/bochs/bochs/main.cc,v
retrieving revision 1.4
diff -c -r1.4 main.cc
*** main.cc	2001/05/02 02:39:23	1.4
--- main.cc	2001/05/03 15:42:29
***************
*** 308,314 ****
      va_start(ap, fmt);
      vfprintf(bx_logfd, fmt, ap);
      va_end(ap);
!     }
  
  #if !BX_PANIC_IS_FATAL
    return;
--- 308,321 ----
      va_start(ap, fmt);
      vfprintf(bx_logfd, fmt, ap);
      va_end(ap);
!   } else {
!     /* panic message is critical to knowing what's going on. print to
!        stderr instead */
!     fprintf(stderr, "bochs: panic, ");
!     va_start(ap, fmt);
!     vfprintf(stderr, fmt, ap);
!     va_end(ap);
!   }
  
  #if !BX_PANIC_IS_FATAL
    return;
***************
*** 527,533 ****
      bx_options.diskc.present = 1;
      }
    else if (!strcmp(params[0], "diskd")) {
-     bx_panic("Diskd not implemented. Use cdromd for CD-ROM support.\n");
      if (num_params != 5) {
        fprintf(stderr, ".bochsrc: diskd directive malformed.\n");
        exit(1);
--- 534,539 ----
***************
*** 890,895 ****
--- 896,904 ----
      fprintf(stderr, ".bochsrc: directive '%s' not understood\n", params[0]);
      exit(1);
      }
+ 
+   if (bx_options.diskd.present && bx_options.cdromd.present)
+     bx_panic ("At present, using both diskd and cdromd at once is not supported.");
  }
  #endif // #if BX_PROVIDE_MAIN
  
Index: bios/rombios.c
===================================================================
RCS file: /cvsroot/bochs/bochs/bios/rombios.c,v
retrieving revision 1.2
diff -c -r1.2 rombios.c
*** bios/rombios.c	2001/04/10 02:19:23	1.2
--- bios/rombios.c	2001/05/03 15:42:34
***************
*** 244,250 ****
  static void           debugger_off();
  static void           keyboard_panic();
  
! #if 0
  #  define printf(format, p...) bios_printf(0, format, ##p)
  #  define panic(format, p...)  bios_printf(1, format, ##p)
  #else
--- 244,250 ----
  static void           debugger_off();
  static void           keyboard_panic();
  
! #if 1
  #  define printf(format, p...) bios_printf(0, format, ##p)
  #  define panic(format, p...)  bios_printf(1, format, ##p)
  #else
***************
*** 1656,1662 ****
  
    /* at this point, DL is >= 0x80 to be passed from the floppy int13h
       handler code */
!   if (GET_DL() > 0x80) { /* only handle one disk for now */
      SET_AH(0x01);
      set_disk_ret_status(0x01);
      SET_CF(); /* error occurred */
--- 1656,1662 ----
  
    /* at this point, DL is >= 0x80 to be passed from the floppy int13h
       handler code */
!   if (GET_DL() > 0x81) { /* allow two disks */
      SET_AH(0x01);
      set_disk_ret_status(0x01);
      SET_CF(); /* error occurred */
***************
*** 1667,1673 ****
  
      case 0x00: /* disk controller reset */
  printf("int13_f00\n");
-       drive = GET_DL();
  
        SET_AH(0);
        set_disk_ret_status(0);
--- 1667,1672 ----
***************
*** 1691,1697 ****
  
      case 0x04: // verify disk sectors
      case 0x02: // read disk sectors
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
--- 1690,1697 ----
  
      case 0x04: // verify disk sectors
      case 0x02: // read disk sectors
!       drive = GET_DL();
!       get_hd_geometry(drive, &hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
***************
*** 1751,1757 ****
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((GET_DL() & 0x01)<<4) | (head & 0x0f));
        outb(0x01f7, 0x20);
  
        while (1) {
--- 1751,1757 ----
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((drive&1)<<4) | (head & 0x0f));
        outb(0x01f7, 0x20);
  
        while (1) {
***************
*** 1828,1834 ****
  
  
      case 0x03: /* write disk sectors */
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
--- 1828,1836 ----
  
  
      case 0x03: /* write disk sectors */
! printf("int13_f03\n");
!       drive = GET_DL ();
!       get_hd_geometry(drive, &hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
***************
*** 1880,1886 ****
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((GET_DL() & 0x01)<<4) | (head & 0x0f));
        outb(0x01f7, 0x30);
  
        // wait for busy bit to turn off after seeking
--- 1882,1888 ----
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((drive&1)<<4) | (head & 0x0f));
        outb(0x01f7, 0x30);
  
        // wait for busy bit to turn off after seeking
***************
*** 1968,1974 ****
  
      case 0x08: /* read disk drive parameters */
  printf("int13_f08\n");
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  
        // translate CHS
        //
--- 1970,1977 ----
  
      case 0x08: /* read disk drive parameters */
  printf("int13_f08\n");
!       // return geom for drive 0x80, they asked for "max" cylinders anyway
!       get_hd_geometry(0x80, &hd_cylinders, &hd_heads, &hd_sectors);
  
        // translate CHS
        //
***************
*** 1998,2004 ****
        SET_CH(max_cylinder & 0xff);
        SET_CL(((max_cylinder >> 2) & 0xc0) | (hd_sectors & 0x3f));
        SET_DH(hd_heads - 1);
!       SET_DL(1); /* one drive for now */
        SET_AH(0);
        set_disk_ret_status(0);
        CLEAR_CF(); /* successful */
--- 2001,2007 ----
        SET_CH(max_cylinder & 0xff);
        SET_CL(((max_cylinder >> 2) & 0xc0) | (hd_sectors & 0x3f));
        SET_DH(hd_heads - 1);
!       SET_DL(2); /* two drives */
        SET_AH(0);
        set_disk_ret_status(0);
        CLEAR_CF(); /* successful */
***************
*** 2080,2087 ****
        break;
  
      case 0x15: /* read disk drive size */
!       // check for driveno in DL here
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  #asm
        push bp
        mov  bp, sp
--- 2083,2090 ----
        break;
  
      case 0x15: /* read disk drive size */
!       drive = GET_DL();
!       get_hd_geometry(drive, &hd_cylinders, &hd_heads, &hd_sectors);
  #asm
        push bp
        mov  bp, sp
***************
*** 2967,2998 ****
  
  
    void
! get_hd_geometry(hd_cylinders, hd_heads, hd_sectors)
    Bit16u *hd_cylinders;
    Bit8u  *hd_heads;
    Bit8u  *hd_sectors;
  {
!   Bit8u hd0_type;
    Bit16u ss;
    Bit16u cylinders;
  
    ss = get_SS();
!   hd0_type = inb_cmos(0x12) & 0xf0;
!   if (hd0_type != 0xf0)
!     panic("HD0 cmos reg 12h not type F\n");
!   hd0_type = inb_cmos(0x19); // HD0: extended type
!   if (hd0_type != 47)
!     panic("HD0 cmos reg 19h not user definable type 47\n");
  
    // cylinders
!   cylinders = inb_cmos(0x1b) | (inb_cmos(0x1c) << 8);
    write_word(ss, hd_cylinders, cylinders);
  
    // heads
!   write_byte(ss, hd_heads, inb_cmos(0x1d));
  
    // sectors per track
!   write_byte(ss, hd_sectors, inb_cmos(0x23));
  }
  
    void
--- 2970,3014 ----
  
  
    void
! get_hd_geometry(drive, hd_cylinders, hd_heads, hd_sectors)
!   Bit8u drive;
    Bit16u *hd_cylinders;
    Bit8u  *hd_heads;
    Bit8u  *hd_sectors;
  {
!   Bit8u hd_type;
    Bit16u ss;
    Bit16u cylinders;
+   Bit8u iobase;
  
    ss = get_SS();
!   if (drive == 0x80) {
!     hd_type = inb_cmos(0x12) & 0xf0;
!     if (hd_type != 0xf0)
!       panic("HD0 cmos reg 12h not type F\n");
!     hd_type = inb_cmos(0x19); // HD0: extended type
!     if (hd_type != 47)
!       panic("HD0 cmos reg 19h not user definable type 47\n");
!     iobase = 0x1b;
!   } else {
!     hd_type = inb_cmos(0x12) & 0x0f;
!     if (hd_type != 0x0f)
!       panic("HD1 cmos reg 12h not type F\n");
!     hd_type = inb_cmos(0x1a); // HD0: extended type
!     if (hd_type != 47)
!       panic("HD1 cmos reg 1ah not user definable type 47\n");
!     iobase = 0x24;
!   }
  
    // cylinders
!   cylinders = inb_cmos(iobase) | (inb_cmos(iobase+1) << 8);
    write_word(ss, hd_cylinders, cylinders);
  
    // heads
!   write_byte(ss, hd_heads, inb_cmos(iobase+2));
  
    // sectors per track
!   write_byte(ss, hd_sectors, inb_cmos(iobase+8));
  }
  
    void
***************
*** 3465,3470 ****
--- 3481,3487 ----
    mov  ax, #EBDA_SEG
    mov  ds, ax
  
+ ;;; Filling EBDA table for hard disk 0.
    mov  al, #0x1f
    out  #0x70, al
    in   al, #0x71
***************
*** 3508,3524 ****
    mov  dl, al      ;; DL = sectors
  
    cmp  bx, #1024
!   jnbe post_logical_chs ;; if cylinders > 1024, use translated style CHS
  
! post_physical_chs:
    ;; no logical CHS mapping used, just physical CHS
    ;; use Standard Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    mov   (0x003d + 0x0E), dl ;; number of physical sectors
!   ret
  
! post_logical_chs:
    ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x09), bx ;; number of physical cylinders
    mov   (0x003d + 0x0b), cl ;; number of physical heads
--- 3525,3541 ----
    mov  dl, al      ;; DL = sectors
  
    cmp  bx, #1024
!   jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
  
! hd0_post_physical_chs:
    ;; no logical CHS mapping used, just physical CHS
    ;; use Standard Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    mov   (0x003d + 0x0E), dl ;; number of physical sectors
!   jmp hd1_setup
  
! hd0_post_logical_chs:
    ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x09), bx ;; number of physical cylinders
    mov   (0x003d + 0x0b), cl ;; number of physical heads
***************
*** 3528,3575 ****
    mov   (0x003d + 0x03), al ;; A0h signature, indicates translated table
  
    cmp bx, #2048
!   jnbe post_above_2048
    ;; 1024 < c <= 2048 cylinders
    shr bx, #0x01
    shl cl, #0x01
!   jmp post_store_logical
  
! post_above_2048:
    cmp bx, #4096
!   jnbe post_above_4096
    ;; 2048 < c <= 4096 cylinders
    shr bx, #0x02
    shl cl, #0x02
!   jmp post_store_logical
  
! post_above_4096:
    cmp bx, #8192
!   jnbe post_above_8192
    ;; 4096 < c <= 8192 cylinders
    shr bx, #0x03
    shl cl, #0x03
!   jmp post_store_logical
  
! post_above_8192:
    ;; 8192 < c <= 16384 cylinders
    shr bx, #0x04
    shl cl, #0x04
  
! post_store_logical:
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    ;; checksum
    mov   cl, #0x0f     ;; repeat count
    mov   si, #0x003d   ;; offset to disk0 FDPT
    mov   al, #0x00     ;; sum
! post_checksum_loop:
    add   al, [si]
    inc   si
    dec   cl
!   jnz post_checksum_loop
    not   al  ;; now take 2s complement
    inc   al
    mov   [si], al
    ret
  
  
--- 3545,3703 ----
    mov   (0x003d + 0x03), al ;; A0h signature, indicates translated table
  
    cmp bx, #2048
!   jnbe hd0_post_above_2048
    ;; 1024 < c <= 2048 cylinders
    shr bx, #0x01
    shl cl, #0x01
!   jmp hd0_post_store_logical
  
! hd0_post_above_2048:
    cmp bx, #4096
!   jnbe hd0_post_above_4096
    ;; 2048 < c <= 4096 cylinders
    shr bx, #0x02
    shl cl, #0x02
!   jmp hd0_post_store_logical
  
! hd0_post_above_4096:
    cmp bx, #8192
!   jnbe hd0_post_above_8192
    ;; 4096 < c <= 8192 cylinders
    shr bx, #0x03
    shl cl, #0x03
!   jmp hd0_post_store_logical
  
! hd0_post_above_8192:
    ;; 8192 < c <= 16384 cylinders
    shr bx, #0x04
    shl cl, #0x04
  
! hd0_post_store_logical:
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    ;; checksum
    mov   cl, #0x0f     ;; repeat count
    mov   si, #0x003d   ;; offset to disk0 FDPT
    mov   al, #0x00     ;; sum
! hd0_post_checksum_loop:
    add   al, [si]
    inc   si
    dec   cl
!   jnz hd0_post_checksum_loop
    not   al  ;; now take 2s complement
    inc   al
    mov   [si], al
+ ;;; Done filling EBDA table for hard disk 0.
+ 
+ hd1_setup:
+ ;;; Filling EBDA table for hard disk 1.
+   mov  al, #0x28
+   out  #0x70, al
+   in   al, #0x71
+   mov  ah, al
+   mov  al, #0x27
+   out  #0x70, al
+   in   al, #0x71
+   mov   (0x004d + 0x05), ax ;; write precomp word
+ 
+   mov  al, #0x29
+   out  #0x70, al
+   in   al, #0x71
+   mov   (0x004d + 0x08), al ;; drive control byte
+ 
+   mov  al, #0x2b
+   out  #0x70, al
+   in   al, #0x71
+   mov  ah, al
+   mov  al, #0x2a
+   out  #0x70, al
+   in   al, #0x71
+   mov   (0x004d + 0x0C), ax ;; landing zone word
+ 
+   mov  al, #0x25   ;; get cylinders word in AX
+   out  #0x70, al
+   in   al, #0x71   ;; high byte
+   mov  ah, al
+   mov  al, #0x24
+   out  #0x70, al
+   in   al, #0x71   ;; low byte
+   mov  bx, ax      ;; BX = cylinders
+ 
+   mov  al, #0x26
+   out  #0x70, al
+   in   al, #0x71
+   mov  cl, al      ;; CL = heads
+ 
+   mov  al, #0x2c
+   out  #0x70, al
+   in   al, #0x71
+   mov  dl, al      ;; DL = sectors
+ 
+   cmp  bx, #1024
+   jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
+ 
+ hd1_post_physical_chs:
+   ;; no logical CHS mapping used, just physical CHS
+   ;; use Standard Fixed Disk Parameter Table (FDPT)
+   mov   (0x004d + 0x00), bx ;; number of physical cylinders
+   mov   (0x004d + 0x02), cl ;; number of physical heads
+   mov   (0x004d + 0x0E), dl ;; number of physical sectors
+   ret
+ 
+ hd1_post_logical_chs:
+   ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
+   mov   (0x004d + 0x09), bx ;; number of physical cylinders
+   mov   (0x004d + 0x0b), cl ;; number of physical heads
+   mov   (0x004d + 0x04), dl ;; number of physical sectors
+   mov   (0x004d + 0x0e), dl ;; number of logical sectors (same)
+   mov al, #0xa0
+   mov   (0x004d + 0x03), al ;; A0h signature, indicates translated table
+ 
+   cmp bx, #2048
+   jnbe hd1_post_above_2048
+   ;; 1024 < c <= 2048 cylinders
+   shr bx, #0x01
+   shl cl, #0x01
+   jmp hd1_post_store_logical
+ 
+ hd1_post_above_2048:
+   cmp bx, #4096
+   jnbe hd1_post_above_4096
+   ;; 2048 < c <= 4096 cylinders
+   shr bx, #0x02
+   shl cl, #0x02
+   jmp hd1_post_store_logical
+ 
+ hd1_post_above_4096:
+   cmp bx, #8192
+   jnbe hd1_post_above_8192
+   ;; 4096 < c <= 8192 cylinders
+   shr bx, #0x03
+   shl cl, #0x03
+   jmp hd1_post_store_logical
+ 
+ hd1_post_above_8192:
+   ;; 8192 < c <= 16384 cylinders
+   shr bx, #0x04
+   shl cl, #0x04
+ 
+ hd1_post_store_logical:
+   mov   (0x004d + 0x00), bx ;; number of physical cylinders
+   mov   (0x004d + 0x02), cl ;; number of physical heads
+   ;; checksum
+   mov   cl, #0x0f     ;; repeat count
+   mov   si, #0x004d   ;; offset to disk0 FDPT
+   mov   al, #0x00     ;; sum
+ hd1_post_checksum_loop:
+   add   al, [si]
+   inc   si
+   dec   cl
+   jnz hd1_post_checksum_loop
+   not   al  ;; now take 2s complement
+   inc   al
+   mov   [si], al
+ ;;; Done filling EBDA table for hard disk 0.
+ 
    ret
  
  
Index: iodev/harddrv.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.cc,v
retrieving revision 1.5
diff -c -r1.5 harddrv.cc
*** iodev/harddrv.cc	2001/05/03 00:41:36	1.5
--- iodev/harddrv.cc	2001/05/03 15:42:37
***************
*** 93,98 ****
--- 93,111 ----
      BX_HD_THIS devices->register_io_write_handler(this, write_handler,
                                          addr, "Hard Drive 0");
      }
+ #if 0
+   // this would be necessary to make the second HD master on the
+   // second controller, using 0x170-0x177 and irq15.  But it currently
+   // works as second disk on the first IDE controller, so this code
+   // is not needed.
+   BX_HD_THIS devices->register_irq(15, "Hard Drive 1");
+   for (unsigned addr=0x0170; addr<=0x0177; addr++) {
+     BX_HD_THIS devices->register_io_read_handler(this, read_handler,
+                                         addr, "Hard Drive 1");
+     BX_HD_THIS devices->register_io_write_handler(this, write_handler,
+                                         addr, "Hard Drive 1");
+     }
+ #endif
  
    BX_HD_THIS drive_select = 0;
  
***************
*** 180,198 ****
--- 193,248 ----
    if (!bx_options.cmos.cmosImage) {
      cmos->s.reg[0x12] = 0x00; // start out with: no drive 0, no drive 1
  
+ //set up cmos for first hard drive
+ //maybe should be conditional on diskc.present.
      // Flag drive type as Fh, use extended CMOS location as real type
      cmos->s.reg[0x12] = (cmos->s.reg[0x12] & 0x0f) | 0xf0;
      cmos->s.reg[0x19] = 47; // user definable type
+     // AMI BIOS: 1st hard disk #cyl low byte
      cmos->s.reg[0x1b] = (bx_options.diskc.cylinders & 0x00ff);
+     // AMI BIOS: 1st hard disk #cyl high byte
      cmos->s.reg[0x1c] = (bx_options.diskc.cylinders & 0xff00) >> 8;
+     // AMI BIOS: 1st hard disk #heads
      cmos->s.reg[0x1d] = (bx_options.diskc.heads);
+     // AMI BIOS: 1st hard disk write precompensation cylinder, low byte
      cmos->s.reg[0x1e] = 0xff; // -1
+     // AMI BIOS: 1st hard disk write precompensation cylinder, high byte
      cmos->s.reg[0x1f] = 0xff; // -1
+     // AMI BIOS: 1st hard disk control byte
      cmos->s.reg[0x20] = 0xc0 | ((bx_options.diskc.heads > 8) << 3);
+     // AMI BIOS: 1st hard disk landing zone, low byte
      cmos->s.reg[0x21] = cmos->s.reg[0x1b];
+     // AMI BIOS: 1st hard disk landing zone, high byte
      cmos->s.reg[0x22] = cmos->s.reg[0x1c];
+     // AMI BIOS: 1st hard disk sectors/track
      cmos->s.reg[0x23] = bx_options.diskc.spt;
  
+     //set up cmos for second hard drive
+     if (bx_options.diskd.present) {
+       bx_printf ("[diskd] I will put 0xf into the second hard disk field");
+       // fill in lower 4 bits of 0x12 for second HD
+       cmos->s.reg[0x12] = (cmos->s.reg[0x12] & 0xf0) | 0x0f;
+       cmos->s.reg[0x1a] = 47; // user definable type
+       // AMI BIOS: 2nd hard disk #cyl low byte
+       cmos->s.reg[0x24] = (bx_options.diskd.cylinders & 0x00ff);
+       // AMI BIOS: 2nd hard disk #cyl high byte
+       cmos->s.reg[0x25] = (bx_options.diskd.cylinders & 0xff00) >> 8;
+       // AMI BIOS: 2nd hard disk #heads
+       cmos->s.reg[0x26] = (bx_options.diskd.heads);
+       // AMI BIOS: 2nd hard disk write precompensation cylinder, low byte
+       cmos->s.reg[0x27] = 0xff; // -1
+       // AMI BIOS: 2nd hard disk write precompensation cylinder, high byte
+       cmos->s.reg[0x28] = 0xff; // -1
+       // AMI BIOS: 2nd hard disk, 0x80 if heads>8
+       cmos->s.reg[0x29] = (bx_options.diskd.heads > 8) ? 0x80 : 0x00;
+       // AMI BIOS: 2nd hard disk landing zone, low byte
+       cmos->s.reg[0x2a] = cmos->s.reg[0x1b];
+       // AMI BIOS: 2nd hard disk landing zone, high byte
+       cmos->s.reg[0x2b] = cmos->s.reg[0x1c];
+       // AMI BIOS: 2nd hard disk sectors/track
+       cmos->s.reg[0x2c] = bx_options.diskd.spt;
+     }
+ 
  
      if ( bx_options.bootdrive[0] == 'c' ) {
        // system boot sequence C:, A:
***************
*** 555,560 ****
--- 605,623 ----
        goto return_value8;
        break;
  
+ #if 0
+       // you'll need these to support second IDE controller, not needed yet.
+       case 0x170:
+       case 0x171:
+       case 0x172:
+       case 0x173:
+       case 0x174:
+       case 0x175:
+       case 0x176:
+       case 0x177:
+ 	    bx_printf ("[disk] ignoring read from 0x%04x\n", address);
+        break;
+ #endif
      default:
        bx_panic("hard drive: io read to address %x unsupported\n",
          (unsigned) address);
***************
*** 1619,1624 ****
--- 1682,1700 ----
  		}
  	  }
  	  break;
+ #if 0
+       // you'll need these to support second IDE controller, not needed yet.
+     case 0x170:
+     case 0x171:
+     case 0x172:
+     case 0x173:
+     case 0x174:
+     case 0x175:
+     case 0x176:
+     case 0x177:
+ 	  bx_printf ("[disk] ignoring write to 0x%04x\n", address);
+        break;
+ #endif
  
      default:
        bx_panic("hard drive: io write to address %x = %02x\n",
***************
*** 2233,2241 ****
  bx_hard_drive_c::raise_interrupt()
  {
        if (!BX_SELECTED_CONTROLLER.control.disable_irq) {
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
! 		  bx_printf("disk: Raising interrupt {%s}\n", DEVICE_TYPE_STRING);
! 	    BX_HD_THIS devices->pic->trigger_irq(14);
        } else {
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
  		  bx_printf("disk: Interrupt masked {%s}\n", DEVICE_TYPE_STRING);
--- 2309,2319 ----
  bx_hard_drive_c::raise_interrupt()
  {
        if (!BX_SELECTED_CONTROLLER.control.disable_irq) {
+ 	    Bit32u irq = 14;  // always 1st IDE controller
+ 	    // for second controller, you would want irq 15
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
! 		  bx_printf("disk: Raising interrupt %d {%s}\n", irq, DEVICE_TYPE_STRING);
! 	    BX_HD_THIS devices->pic->trigger_irq(irq);
        } else {
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
  		  bx_printf("disk: Interrupt masked {%s}\n", DEVICE_TYPE_STRING);
