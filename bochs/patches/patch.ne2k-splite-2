----------------------------------------------------------------------
Patch name: patch.ne2k-splite-2
Author: splite@purdue.edu
Date: Mon, 25 Jun 2001 13:23:22 -0500
RCS Id: $Id: patch.ne2k-splite-2,v 1.1 2001-06-25 21:49:19 bdenney Exp $

Detailed description:
  After much grovelling through the 8390 docs, I think this is the correct
  answer to the odd-length packet problem I was having with the ne2k driver
  under Linux.

  According to the datasheet, the 8390 always accesses its buffer memory in
  word-size chunks if the WTS bit of the DCR is set.  So it will always send
  a word to the host bus interface if WTS==1.  It's up to the host bus
  interface to deliver the the number of requested bytes to the host.  So
  disallowing a byte read when the WTS bit is set is wrong (IMO) as the bus
  interface may allow it, as the NE2000 appears to.

  The patch to ne2k.h bumps the receive buffer memory size to 32K.  This fixes
  the "out-of-bounds chipmem read" errors I was getting.

  Can someone with an NE2K datasheet verify these changes?  They jibe with the
  Linux ne.c driver, anyway.

Patch was created with:
  diff -u
Apply patch to what version:
  cvs current (as of june 25, 2001)
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------

From bochs@sigint.cs.purdue.edu Mon Jun 25 17:23:33 2001
Date: Mon, 25 Jun 2001 13:23:22 -0500
From: bochs@sigint.cs.purdue.edu
To: bochs-developers@lists.sourceforge.net
Subject: [Bochs-developers] ne2k patch for hosted Linux support

After much grovelling through the 8390 docs, I think this is the correct
answer to the odd-length packet problem I was having with the ne2k driver
under Linux.

According to the datasheet, the 8390 always accesses its buffer memory in
word-size chunks if the WTS bit of the DCR is set.  So it will always send
a word to the host bus interface if WTS==1.  It's up to the host bus
interface to deliver the the number of requested bytes to the host.  So
disallowing a byte read when the WTS bit is set is wrong (IMO) as the bus
interface may allow it, as the NE2000 appears to.

The patch to ne2k.h bumps the receive buffer memory size to 32K.  This fixes
the "out-of-bounds chipmem read" errors I was getting.

Can someone with an NE2K datasheet verify these changes?  They jibe with the
Linux ne.c driver, anyway.

--- iodev/ne2k.h.orig	Tue May 22 19:46:47 2001
+++ iodev/ne2k.h	Mon Jun 25 12:30:03 2001
@@ -38,7 +38,7 @@
 #  define BX_NE2K_THIS this->
 #endif
 
-#define  BX_NE2K_MEMSIZ    (16*1024)
+#define  BX_NE2K_MEMSIZ    (32*1024)
 #define  BX_NE2K_MEMSTART  (16*1024)
 #define  BX_NE2K_MEMEND    (BX_NE2K_MEMSTART + BX_NE2K_MEMSIZ)
 
--- iodev/ne2k.cc.orig	Sat Jun 23 19:47:17 2001
+++ iodev/ne2k.cc	Mon Jun 25 12:27:49 2001
@@ -259,22 +259,26 @@
 
   switch (offset) {
   case 0x0:  // Data register
-    // 
-    // The device must have been set up to perform DMA in
-    // the same size as is being requested (the WTS bit
-    // in the DCR), a read remote-DMA command must have
-    // been issued, and the source-address and length
-    // registers must have been initialised.
     //
-    if (io_len != (1 + BX_NE2K_THIS s.DCR.wdsize))
-      BX_PANIC(("dma read, wrong size %d", io_len));
-
-    if (BX_NE2K_THIS s.remote_bytes == 0)
-      BX_PANIC(("ne2K: dma read, byte count 0"));
+    // A read remote-DMA command must have been issued,
+    // and the source-address and length registers must  
+    // have been initialised.
+    //
+    if (io_len > BX_NE2K_THIS s.remote_bytes)
+      BX_PANIC(("ne2K: dma read underrun"));
     
     retval = chipmem_read(BX_NE2K_THIS s.remote_dma, io_len);
-    BX_NE2K_THIS s.remote_dma   += io_len;
-    BX_NE2K_THIS s.remote_bytes -= io_len;
+    //
+    // The 8390 bumps the address and decreases the byte count
+    // by the selected word size after every access, not by
+    // the amount of data requested by the host (io_len).
+    //
+    BX_NE2K_THIS s.remote_dma += (BX_NE2K_THIS s.DCR.wdsize + 1);
+    // keep s.remote_bytes from underflowing
+    if (BX_NE2K_THIS s.remote_bytes > 1)
+      BX_NE2K_THIS s.remote_bytes -= (BX_NE2K_THIS s.DCR.wdsize + 1);
+    else
+      BX_NE2K_THIS s.remote_bytes = 0;
     break;
 
   case 0xf:  // Reset register

_______________________________________________
bochs-developers mailing list
bochs-developers@lists.sourceforge.net
http://lists.sourceforge.net/lists/listinfo/bochs-developers
