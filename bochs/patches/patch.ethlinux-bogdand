----------------------------------------------------------------------
Patch name: patch.ethlinux-bogdand
Author: Bogdan Diaconescu <bogdand@rds.ro>
        adapted for Bochs by Bryce Denney <bryce.denney@bigfoot.com>
Date: Mon, 25 Jun 2001 18:38:31 -0200

Detailed description:
  I have done a patch to make the network for plex86-Linux working.
  The patch could be added to the last CVS version and it implements
  eth_linux.cc using Linux Socket Filtering. I used a thread to make
  readings from the socket in an infinite loop. I tested this
  networking stuff only on Linux so if you test it on other OSes
  please tell me what happend. I did small changes on ne2k.cc source
  and I don't know if the changes works also on Free BSD where they
  worked before. 

Patch was created with:
  cvs diff -u
Apply patch to what version:
  current cvs
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p1 < THIS_PATCH_FILE".
  For now, you must manually add "eth_linux.o" to the list of 
    BX_HW_IODEV_OBJS.
----------------------------------------------------------------------
--- bochs-clean/configure	Mon Jun 25 14:06:44 2001
+++ bochs-ethlinux/configure	Mon Jun 25 12:22:31 2001
@@ -3196,6 +3196,7 @@
   echo "$ac_t""no" 1>&6
 fi
 
+    use_ne2k=yes
    else
     echo "$ac_t""no" 1>&6
     cat >> confdefs.h <<\EOF
@@ -3203,6 +3204,7 @@
 EOF
 
     NE2K_OBJS=''
+    use_ne2k=no
    fi
 else
   
@@ -3212,6 +3214,7 @@
 EOF
 
     NE2K_OBJS=''
+    use_ne2k=no
     
   
 fi
@@ -3220,7 +3223,7 @@
 
 
 echo $ac_n "checking for i440FX PCI support""... $ac_c" 1>&6
-echo "configure:3224: checking for i440FX PCI support" >&5
+echo "configure:3227: checking for i440FX PCI support" >&5
 # Check whether --enable-pci or --disable-pci was given.
 if test "${enable_pci+set}" = set; then
   enableval="$enable_pci"
@@ -3255,7 +3258,7 @@
 
 
 echo $ac_n "checking for port e9 hack""... $ac_c" 1>&6
-echo "configure:3259: checking for port e9 hack" >&5
+echo "configure:3262: checking for port e9 hack" >&5
 # Check whether --enable-port-e9-hack or --disable-port-e9-hack was given.
 if test "${enable_port_e9_hack+set}" = set; then
   enableval="$enable_port_e9_hack"
@@ -3286,7 +3289,7 @@
 
 
 echo $ac_n "checking for use of .cpp as suffix""... $ac_c" 1>&6
-echo "configure:3290: checking for use of .cpp as suffix" >&5
+echo "configure:3293: checking for use of .cpp as suffix" >&5
 # Check whether --enable-cpp or --disable-cpp was given.
 if test "${enable_cpp+set}" = set; then
   enableval="$enable_cpp"
@@ -3328,7 +3331,7 @@
 
 
 echo $ac_n "checking for Bochs internal debugger support""... $ac_c" 1>&6
-echo "configure:3332: checking for Bochs internal debugger support" >&5
+echo "configure:3335: checking for Bochs internal debugger support" >&5
 # Check whether --enable-debugger or --disable-debugger was given.
 if test "${enable_debugger+set}" = set; then
   enableval="$enable_debugger"
@@ -3366,7 +3369,7 @@
 
 
 echo $ac_n "checking for disassembler support""... $ac_c" 1>&6
-echo "configure:3370: checking for disassembler support" >&5
+echo "configure:3373: checking for disassembler support" >&5
 # Check whether --enable-disasm or --disable-disasm was given.
 if test "${enable_disasm+set}" = set; then
   enableval="$enable_disasm"
@@ -3413,7 +3416,7 @@
 
 
 echo $ac_n "checking whether to use readline""... $ac_c" 1>&6
-echo "configure:3417: checking whether to use readline" >&5
+echo "configure:3420: checking whether to use readline" >&5
 # Check whether --enable-readline or --disable-readline was given.
 if test "${enable_readline+set}" = set; then
   enableval="$enable_readline"
@@ -3435,7 +3438,7 @@
 
 if test "$want_readline" = yes; then
   echo $ac_n "checking for readline in -lreadline""... $ac_c" 1>&6
-echo "configure:3439: checking for readline in -lreadline" >&5
+echo "configure:3442: checking for readline in -lreadline" >&5
 ac_lib_var=`echo readline'_'readline | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -3443,7 +3446,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lreadline  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3447 "configure"
+#line 3450 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3454,7 +3457,7 @@
 readline()
 ; return 0; }
 EOF
-if { (eval echo configure:3458: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3461: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3489,17 +3492,17 @@
 
 ac_safe=`echo "readline/history.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for readline/history.h""... $ac_c" 1>&6
-echo "configure:3493: checking for readline/history.h" >&5
+echo "configure:3496: checking for readline/history.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3498 "configure"
+#line 3501 "configure"
 #include "confdefs.h"
 #include <readline/history.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3503: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3506: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -3527,7 +3530,7 @@
 
 
 echo $ac_n "checking for loader support""... $ac_c" 1>&6
-echo "configure:3531: checking for loader support" >&5
+echo "configure:3534: checking for loader support" >&5
 # Check whether --enable-loader or --disable-loader was given.
 if test "${enable_loader+set}" = set; then
   enableval="$enable_loader"
@@ -3565,7 +3568,7 @@
 INSTRUMENT_DIR='instrument/stubs'
 
 echo $ac_n "checking for instrumentation support""... $ac_c" 1>&6
-echo "configure:3569: checking for instrumentation support" >&5
+echo "configure:3572: checking for instrumentation support" >&5
 # Check whether --enable-instrumentation or --disable-instrumentation was given.
 if test "${enable_instrumentation+set}" = set; then
   enableval="$enable_instrumentation"
@@ -3700,7 +3703,7 @@
 
 
 echo $ac_n "checking for VGA emulation""... $ac_c" 1>&6
-echo "configure:3704: checking for VGA emulation" >&5
+echo "configure:3707: checking for VGA emulation" >&5
 # Check whether --enable-vga or --disable-vga was given.
 if test "${enable_vga+set}" = set; then
   enableval="$enable_vga"
@@ -3734,7 +3737,7 @@
 
 
 echo $ac_n "checking for FPU emulation""... $ac_c" 1>&6
-echo "configure:3738: checking for FPU emulation" >&5
+echo "configure:3741: checking for FPU emulation" >&5
 FPU_VAR=''
 FPU_GLUE_OBJ=''
 # Check whether --enable-fpu or --disable-fpu was given.
@@ -3779,7 +3782,7 @@
 
 
 echo $ac_n "checking for x86 debugger support""... $ac_c" 1>&6
-echo "configure:3783: checking for x86 debugger support" >&5
+echo "configure:3786: checking for x86 debugger support" >&5
 # Check whether --enable-x86-debugger or --disable-x86-debugger was given.
 if test "${enable_x86_debugger+set}" = set; then
   enableval="$enable_x86_debugger"
@@ -3815,7 +3818,7 @@
 
 
 echo $ac_n "checking for CDROM support""... $ac_c" 1>&6
-echo "configure:3819: checking for CDROM support" >&5
+echo "configure:3822: checking for CDROM support" >&5
 # Check whether --enable-cdrom or --disable-cdrom was given.
 if test "${enable_cdrom+set}" = set; then
   enableval="$enable_cdrom"
@@ -3857,7 +3860,7 @@
 
 
 echo $ac_n "checking for Sound Blaster 16 support""... $ac_c" 1>&6
-echo "configure:3861: checking for Sound Blaster 16 support" >&5
+echo "configure:3864: checking for Sound Blaster 16 support" >&5
 # Check whether --enable-sb16 or --disable-sb16 was given.
 if test "${enable_sb16+set}" = set; then
   enableval="$enable_sb16"
@@ -4006,7 +4009,7 @@
 
 
 echo $ac_n "checking for gui library to use""... $ac_c" 1>&6
-echo "configure:4010: checking for gui library to use" >&5
+echo "configure:4013: checking for gui library to use" >&5
 
 if (test "$with_x11" != yes) && \
    (test "$with_beos" != yes) && \
@@ -4152,7 +4155,7 @@
 
 if test "$use_curses" = yes; then
   echo $ac_n "checking for mvaddch in -lcurses""... $ac_c" 1>&6
-echo "configure:4156: checking for mvaddch in -lcurses" >&5
+echo "configure:4159: checking for mvaddch in -lcurses" >&5
 ac_lib_var=`echo curses'_'mvaddch | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4160,7 +4163,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4164 "configure"
+#line 4167 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4171,7 +4174,7 @@
 mvaddch()
 ; return 0; }
 EOF
-if { (eval echo configure:4175: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4178: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4192,7 +4195,7 @@
 fi
 
   echo $ac_n "checking for mvaddch in -lncurses""... $ac_c" 1>&6
-echo "configure:4196: checking for mvaddch in -lncurses" >&5
+echo "configure:4199: checking for mvaddch in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'mvaddch | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4200,7 +4203,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4204 "configure"
+#line 4207 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4211,7 +4214,7 @@
 mvaddch()
 ; return 0; }
 EOF
-if { (eval echo configure:4215: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4218: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4232,7 +4235,7 @@
 fi
 
   echo $ac_n "checking for mvaddch in -ltermlib""... $ac_c" 1>&6
-echo "configure:4236: checking for mvaddch in -ltermlib" >&5
+echo "configure:4239: checking for mvaddch in -ltermlib" >&5
 ac_lib_var=`echo termlib'_'mvaddch | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4240,7 +4243,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-ltermlib  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4244 "configure"
+#line 4247 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4251,7 +4254,7 @@
 mvaddch()
 ; return 0; }
 EOF
-if { (eval echo configure:4255: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4258: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4277,21 +4280,21 @@
   fi
 fi
 
-if test "$with_rfb" = yes; then
+if test "$with_rfb" = yes -o "$use_ne2k" = yes; then
   # first see if compiler takes "-pthread" argument
   echo $ac_n "checking for -pthread arg to compiler""... $ac_c" 1>&6
-echo "configure:4284: checking for -pthread arg to compiler" >&5
+echo "configure:4287: checking for -pthread arg to compiler" >&5
   CFLAGS_SAVE="$CFLAGS"
   CFLAGS="$CFLAGS -pthread"
   cat > conftest.$ac_ext <<EOF
-#line 4288 "configure"
+#line 4291 "configure"
 #include "confdefs.h"
  #include <pthread.h> 
 int main() {
  pthread_create(0,0,0,0); 
 ; return 0; }
 EOF
-if { (eval echo configure:4295: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4298: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
    
       # it compiles with -pthread
@@ -4307,7 +4310,7 @@
       # now try with -lpthread
       CFLAGS="$CFLAGS_SAVE"
       echo $ac_n "checking for pthread_create in -lpthread""... $ac_c" 1>&6
-echo "configure:4311: checking for pthread_create in -lpthread" >&5
+echo "configure:4314: checking for pthread_create in -lpthread" >&5
 ac_lib_var=`echo pthread'_'pthread_create | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -4315,7 +4318,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lpthread  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 4319 "configure"
+#line 4322 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4326,7 +4329,7 @@
 pthread_create()
 ; return 0; }
 EOF
-if { (eval echo configure:4330: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4333: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -4378,7 +4381,7 @@
 # Extract the first word of "gzip", so it can be a program name with args.
 set dummy gzip; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4382: checking for $ac_word" >&5
+echo "configure:4385: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GZIP'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -4413,7 +4416,7 @@
 # Extract the first word of "tar", so it can be a program name with args.
 set dummy tar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4417: checking for $ac_word" >&5
+echo "configure:4420: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_TAR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
--- bochs-clean/configure.in	Mon Jun 25 14:06:44 2001
+++ bochs-ethlinux/configure.in	Mon Jun 25 12:22:27 2001
@@ -311,15 +311,18 @@
     AC_DEFINE(BX_NE2K_SUPPORT, 1)
     NE2K_OBJS='ne2k.o eth.o eth_null.o'
     AC_CHECK_HEADER(net/bpf.h, NE2K_OBJS="$NE2K_OBJS eth_fbsd.o")
+    use_ne2k=yes
    else
     AC_MSG_RESULT(no)
     AC_DEFINE(BX_NE2K_SUPPORT, 0)
     NE2K_OBJS=''
+    use_ne2k=no
    fi],
   [
     AC_MSG_RESULT(no)
     AC_DEFINE(BX_NE2K_SUPPORT, 0)
     NE2K_OBJS=''
+    use_ne2k=no
     ]
   )
 AC_SUBST(NE2K_OBJS)
@@ -891,7 +894,7 @@
   fi
 fi
 
-if test "$with_rfb" = yes; then
+if test "$with_rfb" = yes -o "$use_ne2k" = yes; then
   # first see if compiler takes "-pthread" argument
   AC_MSG_CHECKING(for -pthread arg to compiler)
   CFLAGS_SAVE="$CFLAGS"
--- bochs-clean/iodev/eth.h	Mon Jun 25 14:06:46 2001
+++ bochs-ethlinux/iodev/eth.h	Mon Jun 25 12:32:08 2001
@@ -75,6 +75,6 @@
 #if defined(__FreeBSD__) || defined(__OpenBSD__)
 #define ETH_FBSD  1
 #endif
-#if (0 && defined(linux))
+#if defined(linux)
 #define ETH_LINUX 1
 #endif
--- bochs-clean/iodev/eth_linux.cc	Mon Jun 25 14:14:17 2001
+++ bochs-ethlinux/iodev/eth_linux.cc	Mon Jun 25 12:19:04 2001
@@ -0,0 +1,272 @@
+//
+//  This library is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU Lesser General Public
+//  License as published by the Free Software Foundation; either
+//  version 2 of the License, or (at your option) any later version.
+//
+//  This library is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//  Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public
+//  License along with this library; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+// eth_linux.cc  - linux code for an ethernet pktmover
+
+// Bogdan Diaconescu (bogdand@rds.ro) coded all of this
+// NE2000/ether stuff.
+//
+// eth_linux.cc is a Linux implementation of the ethernet packetmover. It uses
+// Linux Socket Filtering which is very close to BPF. I used a thread to poll
+// the socket in an infinite loop. Anyway there are somme problems with the
+// approach I choosed to implement the guest<->host interface:
+// - the guestOS is not able to connect with the hostOS.
+// - the host ethernet interface is put in promiscuous mode.
+//  
+//  ne2k: ioaddr=0x280, irq=10, mac=00:a:b:c:1:2, ethmod=linux, ethdev=eth0
+
+#include "bochs.h"
+
+#define LOG_THIS bx_ne2k.
+
+extern "C" {
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <linux/if_ether.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netpacket/packet.h>
+#include <pcap/net/bpf.h>
+#include <errno.h>
+#include <pthread.h>
+};
+
+#define BX_BPF_INSNSIZ  8		// number of bpf insns
+
+static const struct bpf_insn macfilter[] = {
+  BPF_STMT(BPF_LD|BPF_W|BPF_ABS, 2),
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, 0xaaaaaaaa, 0, 2),
+  BPF_STMT(BPF_LD|BPF_H|BPF_ABS, 0),
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, 0x0000aaaa, 2, 0),
+  BPF_STMT(BPF_LD|BPF_B|BPF_ABS, 0),
+  BPF_JUMP(BPF_JMP|BPF_JSET|BPF_K, 0x01, 0, 1),
+  BPF_STMT(BPF_RET, 1514),
+  BPF_STMT(BPF_RET, 0),
+}; 
+
+#define ARPHRD_ETHER    1     /* Ethernet 10Mbps      */
+#define  ARPHRD_EETHER  2     /* Experimental Ethernet   */
+
+pthread_t pt;
+void* recv_th(void*);
+
+//
+//  define the class. This is private to this module
+//
+
+class bx_linux_pktmover_c : public eth_pktmover_c {
+public:
+  bx_linux_pktmover_c(const char *netif, const char *macaddr,
+		     eth_rx_handler_t rxh,
+		     void *rxarg);
+  void sendpkt(void *buf, unsigned io_len);
+	void rx_timer(void);
+private:	
+	char* linux_macaddr[6];
+	int bpf_fd;
+	struct bpf_insn filter[BX_BPF_INSNSIZ];
+	Bit8u* rxbuf;
+};
+
+
+bx_linux_pktmover_c* this_ptr;
+
+//
+//  Define the static class that registers the derived pktmover class,
+// and allocates one on request.
+//
+class bx_linux_locator_c : public eth_locator_c {
+public:
+  bx_linux_locator_c(void) : eth_locator_c("linux") {}
+protected:
+  eth_pktmover_c *allocate(const char *netif, const char *macaddr,
+			   eth_rx_handler_t rxh,
+			   void *rxarg) {
+    return (new bx_linux_pktmover_c(netif, macaddr, rxh, rxarg));
+  }
+} bx_linux_match;
+
+
+//
+// Define the methods for the bx_linux_pktmover derived class
+//
+
+// the constructor
+//
+// Open a socket and bind it to the interface
+//
+bx_linux_pktmover_c::bx_linux_pktmover_c(const char *netif, 
+				       const char *macaddr,
+				       eth_rx_handler_t rxh,
+				       void *rxarg)
+{
+	char device[sizeof "ethXX"];
+	struct ifreq ifr, saved_ifr;
+	struct sockaddr_ll sl;
+	int linktype;
+	int mtu;
+	struct bpf_program bp;
+	
+	memcpy(linux_macaddr, macaddr, 6);
+	strcpy(device, netif);
+	bpf_fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
+	if (this->bpf_fd < 0) {
+    BX_ERROR (("ne2k: could not open socket: %s\n", strerror(errno)));
+    return;
+  }
+
+	/* get the interface index */
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	if (ioctl(this->bpf_fd, SIOCGIFINDEX, &ifr) < 0 ) {
+		BX_ERROR(("ne2k: SIOCGIFINDEX: %s\n", strerror(errno)));
+		close(this->bpf_fd);
+		return;
+	}
+	BX_INFO(("ne2k: interface index is %i\n", ifr.ifr_ifindex));
+
+	/* bind the socket to the interface */
+  memset(&sl, 0, sizeof(sl));
+  sl.sll_family = AF_PACKET;
+  sl.sll_protocol = htonl(ETH_P_ALL);
+  sl.sll_ifindex = ifr.ifr_ifindex;
+  if (bind(this->bpf_fd, (struct sockaddr*)&sl, sizeof(sl))) {
+    BX_ERROR (("error binding interface %s: %s\n", device, strerror(errno));
+		close(this->bpf_fd));
+		return;
+  }
+
+	/* get the media link type */
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	if (ioctl(this->bpf_fd, SIOCGIFHWADDR, &ifr) < 0 ) {
+		BX_ERROR (("ne2k: SIOCGIFHWADDR: %s\n", strerror(errno)));
+		close(this->bpf_fd);
+		return;
+	}
+  switch (ifr.ifr_hwaddr.sa_family) {
+    case ARPHRD_ETHER:
+    case ARPHRD_EETHER:
+        linktype = DLT_EN10MB;
+        break;
+    default:
+      BX_ERROR (("ne2k: found unknown media!\n"));
+      return;
+  }
+	
+	/* Base the buffer size on the interface MTU */
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
+	if (ioctl(this->bpf_fd, SIOCGIFMTU, &ifr) < 0 ) {
+		BX_ERROR(("ne2k: SIOCGIFMTU: %s", strerror(errno)));
+		close(this->bpf_fd);
+		return;
+	}
+  mtu = ifr.ifr_mtu;
+  BX_INFO (("ne2k: MTU is %i\n", ifr.ifr_mtu));
+	/* alloc the RX buffer */
+	this->rxbuf = (Bit8u*)malloc(mtu + 64);
+
+	/* put the interface in promiscuous mode */
+  memset(&ifr, 0, sizeof(ifr));
+	strcpy(ifr.ifr_name, device);
+	if (ioctl(this->bpf_fd, SIOCGIFFLAGS, &ifr) < 0 ) {
+		BX_ERROR(("ne2k: SIOCGIFFLAGS: %s", strerror(errno)));
+		close(this->bpf_fd);
+    return;
+	}
+	saved_ifr = ifr;
+	ifr.ifr_flags |= IFF_PROMISC;
+	if (ioctl(this->bpf_fd, SIOCSIFFLAGS, &ifr) < 0 ) {
+		BX_ERROR(("ne2k: SIOCSIFFLAGS: %s", strerror(errno)));
+		close(this->bpf_fd);
+		return;
+	}
+	ifr.ifr_flags &= ~IFF_PROMISC;
+	BX_INFO (("ne2k: interface %s in promisc mode now\n", device));
+
+	/* now install the filter */
+	memcpy(&this->filter, macfilter, sizeof(macfilter));
+  this->filter[1].k = (macaddr[2] & 0xff) << 24 |
+    (macaddr[3] & 0xff) << 16 |
+    (macaddr[4] & 0xff) << 8  |
+    (macaddr[5] & 0xff);
+  this->filter[3].k = (macaddr[0] & 0xff) << 8 |
+    (macaddr[1] & 0xff);
+  bp.bf_len   = 8;
+  bp.bf_insns = &this->filter[0];
+  int ret;
+  ret = setsockopt(this->bpf_fd, SOL_SOCKET, SO_ATTACH_FILTER, &bp, sizeof(bp));  if (ret < 0){
+    BX_ERROR(("ne2k: setsockopt: %s\n", strerror(errno)));
+		close(this->bpf_fd);
+    return;
+  }
+  BX_INFO (("ne2k: bpf filter registered\n"));
+
+	/* start the RX poll using a thread */
+	pthread_create(&pt, NULL, recv_th, NULL);
+	this_ptr = this;
+
+	this->rxh   = rxh;
+  this->rxarg = rxarg; 
+}
+
+// the output routine - called with pre-formatted ethernet frame.
+void
+bx_linux_pktmover_c::sendpkt(void *buf, unsigned io_len)
+{
+	int status = 0;
+ 
+  if (this->bpf_fd != -1)
+    status = write(this->bpf_fd, buf, io_len);
+  if (status < 0)
+    BX_ERROR(("ne2k: error on write packet: %s\n", strerror(errno)));
+}
+
+
+void
+bx_linux_pktmover_c::rx_timer(void)
+{
+  int nbytes = 0;
+ 
+  nbytes = read(this->bpf_fd, this->rxbuf, 2048);
+  if (nbytes < 0)
+    BX_ERROR(("ne2k: error on receive packet: %s\n", strerror(errno)));
+
+#ifdef undef 
+  printf("packet rx (%d bytes):\n\t", nbytes);
+    for (int i = 0; i < nbytes; i++) {
+      printf("%02x ", rxbuf[i]);
+      if (i && (((i+1) % 16) == 0))
+    	printf("\n\t");
+    }
+    printf("\n");
+#endif
+ 
+  if (nbytes > 0) {
+  	(*rxh)(rxarg, rxbuf, nbytes);
+ }
+
+} 
+
+
+void* recv_th(void* args){
+	int i = 0;
+	do{
+		this_ptr->rx_timer();
+		i++;
+	}while(1);
+}
--- bochs-clean/iodev/ne2k.cc	Mon Jun 25 14:06:48 2001
+++ bochs-ethlinux/iodev/ne2k.cc	Mon Jun 25 12:24:21 2001
@@ -124,6 +124,7 @@
   if (value & 0x01) {
     BX_NE2K_THIS s.ISR.reset = 1;
     BX_NE2K_THIS s.CR.stop   = 1;
+    BX_NE2K_THIS s.CR.start = 0;
   } else {
     BX_NE2K_THIS s.CR.stop = 0;
   }
@@ -134,9 +135,9 @@
   // must be cleared
   if ((value & 0x02) && !BX_NE2K_THIS s.CR.start) {
     BX_NE2K_THIS s.ISR.reset = 0;
+  	BX_NE2K_THIS s.CR.start = ((value & 0x02) == 0x02);
   }
 
-  BX_NE2K_THIS s.CR.start = ((value & 0x02) == 0x02);
   BX_NE2K_THIS s.CR.pgsel = (value & 0xc0) >> 6;
 
   // Check for start-tx
@@ -185,7 +186,7 @@
       BX_NE2K_THIS s.remote_bytes == 0) {
     BX_NE2K_THIS s.ISR.rdma_done = 1;
     if (BX_NE2K_THIS s.IMR.rdma_inte) {
-      BX_NE2K_THIS devices->pic->trigger_irq(BX_NE2K_THIS s.base_irq);
+    	raise_interrupt(); 
     }
   }
 }
@@ -267,7 +268,7 @@
     // registers must have been initialised.
     //
     if (io_len != (1 + BX_NE2K_THIS s.DCR.wdsize))
-      BX_PANIC(("dma read, wrong size %d", io_len));
+      BX_ERROR(("dma read, wrong size %d", io_len));
 
     if (BX_NE2K_THIS s.remote_bytes == 0)
       BX_PANIC(("ne2K: dma read, byte count 0"));
@@ -880,7 +881,7 @@
   // Generate an interrupt if not masked and not one in progress
   if (BX_NE2K_THIS s.IMR.tx_inte && !BX_NE2K_THIS s.ISR.pkt_tx) {
     BX_NE2K_THIS s.ISR.pkt_tx = 1;
-    BX_NE2K_THIS devices->pic->trigger_irq(BX_NE2K_THIS s.base_irq);
+    raise_interrupt();
   }
   BX_NE2K_THIS s.tx_timer_active = 0;
 }
@@ -1147,7 +1148,7 @@
   BX_NE2K_THIS s.ISR.pkt_rx = 1;
 
   if (BX_NE2K_THIS s.IMR.rx_inte) {
-    BX_NE2K_THIS devices->pic->trigger_irq(BX_NE2K_THIS s.base_irq);
+    raise_interrupt();
   }
 
 }
@@ -1234,4 +1235,10 @@
 	BX_PANIC(("could not locate null module"));
     }
   }
+}
+
+void
+bx_ne2k_c::raise_interrupt()
+{ 
+    bx_devices.pic->trigger_irq (BX_NE2K_THIS s.base_irq);
 }
--- bochs-clean/iodev/ne2k.h	Mon Jun 25 14:06:48 2001
+++ bochs-ethlinux/iodev/ne2k.h	Mon Jun 25 11:49:15 2001
@@ -202,6 +202,8 @@
 
   eth_pktmover_c *ethdev;
 
+	BX_NE2K_SMF void raise_interrupt();
+
   BX_NE2K_SMF void   reset_device(void);
   BX_NE2K_SMF Bit32u read_cr(void);
   BX_NE2K_SMF void   write_cr(Bit32u value);
