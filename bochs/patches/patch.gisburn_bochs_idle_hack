----------------------------------------------------------------------
Patch name: patch.gisburn_bochs_idle_hack
Author: Roland.Mainz@informatik.med.uni-giessen.de
Date: Thu, 04 Oct 2001 12:47:50 +0200
RCS Id: $Id: patch.gisburn_bochs_idle_hack,v 1.1 2001-10-04 18:37:29 bdenney Exp $

Detailed description:
I've attached a smallish "hack" to prevent that bochs always consumes
100% CPU time - even if the "guest OS" is idle... which is very anoying
on machines which only have one host CPU ...
... is there any interest in hacking-up a better solution (e.g. making
the code platform-independent for example) ?

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on DATE, release version VER
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p1 < THIS_PATCH_FILE".
----------------------------------------------------------------------

--- original/bochs-1.2.1/cpu/proc_ctrl.cc	Thu May 24 20:46:34 2001
+++ bochs-1.2.1/cpu/proc_ctrl.cc	Thu Oct  4 12:26:39 2001
@@ -21,10 +21,29 @@
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 
 
-
-
-
-
+/* GISBURN_IDLE_HACK: a smallish, silly idle hack to prevent bochs
+ * from consuming 100% CPU time even when it is not required (for
+ * example, the OS in the emulator calls HLT to wait for an interupt)
+ * pro:
+ * - no more 100% CPU usage
+ * contra:
+ * - we're sleeping too long
+ * - bochs still consumes ~10%-20% CPU time while executing an idle 
+ *   linux kernel
+ * - this is an hack
+ * - we really really should move this into X11 display code part
+ */
+#define GISBURN_IDLE_HACK 1
+
+#ifdef GISBURN_IDLE_HACK
+extern "C" {
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xos.h>
+#include <X11/Xatom.h>
+#include <X11/keysym.h>
+}
+#endif /* GISBURN_IDLE_HACK */
 
 #define NEED_CPU_REG_SHORTCUTS 1
 #include "bochs.h"
@@ -51,6 +70,55 @@
 {
 }
 
+#ifdef GISBURN_IDLE_HACK
+/* XPeekEvent() with timeout 
+ * (adopted from mozilla/gfx/src/xprint/xprintutil_printtofile.c#XNextEventTimeout())
+ */
+static
+Bool XPeekEventTimeout( Display *display, XEvent *event_return, struct timeval *timeout ) 
+{
+    int      res;
+    fd_set   readfds;
+    int      display_fd = XConnectionNumber(display);
+
+    /* small shortcut... */
+    if( timeout == NULL )
+    {
+      XPeekEvent(display, event_return);
+      return(True);
+    }
+    
+    FD_ZERO(&readfds);
+    FD_SET(display_fd, &readfds);
+
+    /* Note/bug: In the case of internal X events (like used to trigger callbacks 
+     * registered by XpGetDocumentData()&co.) select() will return with "new info" 
+     * - but XNextEvent() below processes these _internal_ events silently - and 
+     * will block if there are no other non-internal events.
+     * The workaround here is to check with XEventsQueued() if there are non-internal 
+     * events queued - if not select() will be called again - unfortunately we use 
+     * the old timeout here instead of the "remaining" time... (this only would hurt 
+     * if the timeout would be really long - but for current use with values below
+     * 1/2 secs it does not hurt... =:-)
+     */
+    while( XEventsQueued(display, QueuedAfterFlush) == 0 )
+    {
+      res = select(display_fd+1, &readfds, NULL, NULL, timeout);
+    
+      switch(res)
+      {
+        case -1: /* select() error - should not happen */ 
+            perror("XPeekEventTimeout: select() failure"); 
+            return(False);
+        case  0: /* timeout */
+          return(False);
+      }
+    }
+    
+    XPeekEvent(display, event_return); 
+    return(True);
+}
+#endif /* GISBURN_IDLE_HACK */  
 
   void
 BX_CPU_C::HLT(BxInstruction_t *i)
@@ -81,6 +149,15 @@
   // Execution of this instruction completes.  The processor
   // will remain in a halt state until one of the above conditions
   // is met.
+
+#ifdef GISBURN_IDLE_HACK  
+  extern Display *bx_x_display;  
+  XEvent dummy;
+  struct timeval   timeout;   
+  timeout.tv_sec  = 0;
+  timeout.tv_usec = 1000; /* 1/1000 s */  
+  XPeekEventTimeout(bx_x_display, &dummy, &timeout);
+#endif /* GISBURN_IDLE_HACK */  
 }
 
 
