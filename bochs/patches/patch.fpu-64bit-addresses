----------------------------------------------------------------------
Patch name: patch.fpu-64bit-addresses 
Author: ???
Date: ???
Status: applied to the main code

Detailed description:
	64bit address support for FPU emulation

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on DATE, release version VER
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".

----------------------------------------------------------------------
Index: fpu/fpu_emu.h
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_emu.h,v
retrieving revision 1.9
diff -u -r1.9 fpu_emu.h
--- fpu/fpu_emu.h	12 Apr 2003 21:02:07 -0000	1.9
+++ fpu/fpu_emu.h	9 Jun 2003 01:34:24 -0000
@@ -116,7 +116,7 @@
 #define PREFIX_DEFAULT 7
 
 struct address {
-  u32 offset;
+  bx_address offset;
 #ifdef EMU_BIG_ENDIAN
   u32 empty:5;
   u32 opcode:11;
Index: fpu/fpu_entry.c
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_entry.c,v
retrieving revision 1.9
diff -u -r1.9 fpu_entry.c
--- fpu/fpu_entry.c	15 May 2003 16:19:38 -0000	1.9
+++ fpu/fpu_entry.c	9 Jun 2003 01:34:24 -0000
@@ -134,7 +134,7 @@
 math_emulate(fpu_addr_modes addr_modes,
               u_char  FPU_modrm,
               u_char byte1,
-              void *data_address,
+              bx_address data_address,
               struct address data_sel_off,
               struct address entry_sel_off)
 {
@@ -211,7 +211,7 @@
               switch ( (byte1 >> 1) & 3 )
                 {
                 case 0:
-                  unmasked = FPU_load_single((float *)data_address,
+                  unmasked = FPU_load_single(data_address,
                                              &loaded_data);
                   loaded_tag = unmasked & 0xff;
                   unmasked &= ~0xff;
@@ -220,14 +220,14 @@
                   loaded_tag = FPU_load_int32((s32 *)data_address, &loaded_data);
                   break;
                 case 2:
-                  unmasked = FPU_load_double((double *)data_address,
+                  unmasked = FPU_load_double(data_address,
                                              &loaded_data);
                   loaded_tag = unmasked & 0xff;
                   unmasked &= ~0xff;
                   break;
                 case 3:
                 default:  /* Used here to suppress gcc warnings. */
-                  loaded_tag = FPU_load_int16((s16 *)data_address, &loaded_data);
+                  loaded_tag = FPU_load_int16(data_address, &loaded_data);
                   break;
                 }
 
Index: fpu/fpu_proto.h
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_proto.h,v
retrieving revision 1.7
diff -u -r1.7 fpu_proto.h
--- fpu/fpu_proto.h	22 Apr 2003 20:21:34 -0000	1.7
+++ fpu/fpu_proto.h	9 Jun 2003 01:34:27 -0000
@@ -111,7 +111,7 @@
 extern void FPU_trigb(void);
 /* load_store.c */
 extern int FPU_load_store(u_char type, fpu_addr_modes addr_modes,
-			    void *data_address);
+			    bx_address data_address);
 /* poly_2xm1.c */
 extern int poly_2xm1(u_char sign, FPU_REG *arg, FPU_REG *result);
 /* poly_atan.c */
@@ -140,26 +140,26 @@
 /* reg_constant.c */
 extern void fconst(void);
 /* reg_ld_str.c */
-extern int FPU_load_extended(long double *s, int stnr) BX_CPP_AttrRegparmN(2);
-extern int FPU_load_double(double *dfloat, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
-extern int FPU_load_single(float *single, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
-extern int FPU_load_int64(s64 *_s) BX_CPP_AttrRegparmN(1);
-extern int FPU_load_int32(s32 *_s, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
-extern int FPU_load_int16(s16 *_s, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
-extern int FPU_load_bcd(u_char *s) BX_CPP_AttrRegparmN(1);
+extern int FPU_load_extended(bx_address s, int stnr) BX_CPP_AttrRegparmN(2);
+extern int FPU_load_double(bx_address dfloat, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
+extern int FPU_load_single(bx_address single, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
+extern int FPU_load_int64(bx_address _s) BX_CPP_AttrRegparmN(1);
+extern int FPU_load_int32(bx_address _s, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
+extern int FPU_load_int16(bx_address _s, FPU_REG *loaded_data) BX_CPP_AttrRegparmN(2);
+extern int FPU_load_bcd(bx_address s) BX_CPP_AttrRegparmN(1);
 extern int FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag,
-			      long double *d) BX_CPP_AttrRegparmN(3);
-extern int FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double *dfloat) BX_CPP_AttrRegparmN(3);
-extern int FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float *single) BX_CPP_AttrRegparmN(3);
-extern int FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, s64 *d) BX_CPP_AttrRegparmN(3);
-extern int FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, s32 *d) BX_CPP_AttrRegparmN(3);
-extern int FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, s16 *d) BX_CPP_AttrRegparmN(3);
-extern int FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char *d) BX_CPP_AttrRegparmN(3);
+			      bx_address d) BX_CPP_AttrRegparmN(3);
+extern int FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, bx_address dfloat) BX_CPP_AttrRegparmN(3);
+extern int FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, bx_address single) BX_CPP_AttrRegparmN(3);
+extern int FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, bx_address d) BX_CPP_AttrRegparmN(3);
+extern int FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, bx_address d) BX_CPP_AttrRegparmN(3);
+extern int FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, bx_address d) BX_CPP_AttrRegparmN(3);
+extern int FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, bx_address d) BX_CPP_AttrRegparmN(3);
 extern int FPU_round_to_int(FPU_REG *r, u_char tag) BX_CPP_AttrRegparmN(2);
-extern u_char *fldenv(fpu_addr_modes addr_modes, u_char *s) BX_CPP_AttrRegparmN(2);
-extern void frstor(fpu_addr_modes addr_modes, u_char *data_address) BX_CPP_AttrRegparmN(2);
-extern u_char *fstenv(fpu_addr_modes addr_modes, u_char *d) BX_CPP_AttrRegparmN(2);
-extern void fsave(fpu_addr_modes addr_modes, u_char *data_address) BX_CPP_AttrRegparmN(2);
+extern bx_address fldenv(fpu_addr_modes addr_modes, bx_address s) BX_CPP_AttrRegparmN(2);
+extern void frstor(fpu_addr_modes addr_modes, bx_address data_address) BX_CPP_AttrRegparmN(2);
+extern bx_address fstenv(fpu_addr_modes addr_modes, bx_address d) BX_CPP_AttrRegparmN(2);
+extern void fsave(fpu_addr_modes addr_modes, bx_address data_address) BX_CPP_AttrRegparmN(2);
 extern int FPU_tagof(FPU_REG *ptr) BX_CPP_AttrRegparmN(1);
 /* reg_mul.c */
 extern int FPU_mul(FPU_REG const *b, u_char tagb, int deststnr, int control_w);
Index: fpu/fpu_system.h
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_system.h,v
retrieving revision 1.9
diff -u -r1.9 fpu_system.h
--- fpu/fpu_system.h	20 Apr 2003 19:20:07 -0000	1.9
+++ fpu/fpu_system.h	9 Jun 2003 01:34:27 -0000
@@ -47,10 +47,11 @@
 #endif
 
 
-extern unsigned fpu_get_user(void *ptr, unsigned len) BX_CPP_AttrRegparmN(2);
-extern void fpu_put_user(unsigned val, void *ptr, unsigned len) BX_CPP_AttrRegparmN(2);
+extern unsigned fpu_get_user(bx_address ptr, unsigned len) BX_CPP_AttrRegparmN(2);
+extern void fpu_put_user(unsigned val, bx_address ptr, unsigned len) BX_CPP_AttrRegparmN(2);
 
-extern void fpu_verify_area(unsigned what, void *ptr, unsigned n) BX_CPP_AttrRegparmN(3);
+extern void fpu_verify_area(unsigned what, bx_address ptr, unsigned n) BX_CPP_AttrRegparmN(3);
+extern void math_emulate_init(void);
 extern unsigned fpu_get_ds(void);
 extern void fpu_set_ax(u16);
 
@@ -86,9 +87,9 @@
 #define instruction_address     (*(struct address *)&i387.fip)
 #define operand_address         (*(struct address *)&i387.foo)
 
-#define FPU_verify_area(x,y,z)	fpu_verify_area((x),(y),(z))
-#define FPU_get_user(x,y)       ((x) = fpu_get_user((y), sizeof(*(y))))
-#define FPU_put_user(val,ptr)   fpu_put_user((val),(ptr),sizeof(*(ptr)))
+#define FPU_verify_area(x,y,z)	fpu_verify_area(x,(bx_address)(y),z)
+#define FPU_get_user(val,ptr,len)       ((val) = fpu_get_user((ptr), (len)))
+#define FPU_put_user(val,ptr,len)   fpu_put_user((val),(ptr),(len))
 
 #define FPU_DS  (fpu_get_ds())
 
Index: fpu/load_store.c
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/load_store.c,v
retrieving revision 1.6
diff -u -r1.6 load_store.c
--- fpu/load_store.c	16 Apr 2003 18:38:53 -0000	1.6
+++ fpu/load_store.c	9 Jun 2003 01:34:27 -0000
@@ -60,7 +60,7 @@
 };
 
 int FPU_load_store(u_char type, fpu_addr_modes addr_modes,
-		     void *data_address)
+		     bx_address data_address)
 {
   FPU_REG loaded_data;
   FPU_REG *st0_ptr;
@@ -121,7 +121,7 @@
     {
     case 000:       /* fld m32real */
       clear_C1();
-      loaded_tag = FPU_load_single((float *)data_address, &loaded_data);
+      loaded_tag = FPU_load_single(data_address, &loaded_data);
       if ( (loaded_tag == TAG_Special)
 	   && isNaN(&loaded_data)
 	   && (real_1op_NaN(&loaded_data) < 0) )
@@ -133,12 +133,12 @@
       break;
     case 001:      /* fild m32int */
       clear_C1();
-      loaded_tag = FPU_load_int32((s32 *)data_address, &loaded_data);
+      loaded_tag = FPU_load_int32(data_address, &loaded_data);
       FPU_copy_to_reg0(&loaded_data, loaded_tag);
       break;
     case 002:      /* fld m64real */
       clear_C1();
-      loaded_tag = FPU_load_double((double *)data_address, &loaded_data);
+      loaded_tag = FPU_load_double(data_address, &loaded_data);
       if ( (loaded_tag == TAG_Special)
 	   && isNaN(&loaded_data)
 	   && (real_1op_NaN(&loaded_data) < 0) )
@@ -150,68 +150,68 @@
       break;
     case 003:      /* fild m16int */
       clear_C1();
-      loaded_tag = FPU_load_int16((s16 *)data_address, &loaded_data);
+      loaded_tag = FPU_load_int16(data_address, &loaded_data);
       FPU_copy_to_reg0(&loaded_data, loaded_tag);
       break;
     case 010:      /* fst m32real */
       clear_C1();
-      FPU_store_single(st0_ptr, st0_tag, (float *)data_address);
+      FPU_store_single(st0_ptr, st0_tag, data_address);
       break;
     case 011:      /* fist m32int */
       clear_C1();
-      FPU_store_int32(st0_ptr, st0_tag, (s32 *)data_address);
+      FPU_store_int32(st0_ptr, st0_tag, data_address);
       break;
     case 012:     /* fst m64real */
       clear_C1();
-      FPU_store_double(st0_ptr, st0_tag, (double *)data_address);
+      FPU_store_double(st0_ptr, st0_tag, data_address);
       break;
     case 013:     /* fist m16int */
       clear_C1();
-      FPU_store_int16(st0_ptr, st0_tag, (s16 *)data_address);
+      FPU_store_int16(st0_ptr, st0_tag, data_address);
       break;
     case 014:     /* fstp m32real */
       clear_C1();
-      if ( FPU_store_single(st0_ptr, st0_tag, (float *)data_address) )
+      if ( FPU_store_single(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
     case 015:     /* fistp m32int */
       clear_C1();
-      if ( FPU_store_int32(st0_ptr, st0_tag, (s32 *)data_address) )
+      if ( FPU_store_int32(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
     case 016:     /* fstp m64real */
       clear_C1();
-      if ( FPU_store_double(st0_ptr, st0_tag, (double *)data_address) )
+      if ( FPU_store_double(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
     case 017:     /* fistp m16int */
       clear_C1();
-      if ( FPU_store_int16(st0_ptr, st0_tag, (s16 *)data_address) )
+      if ( FPU_store_int16(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
     case 020:     /* fldenv  m14/28byte */
-      fldenv(addr_modes, (u_char *)data_address);
+      fldenv(addr_modes, data_address);
       /* Ensure that the values just loaded are not changed by
 	 fix-up operations. */
       return 1;
     case 022:     /* frstor m94/108byte */
-      frstor(addr_modes, (u_char *)data_address);
+      frstor(addr_modes, data_address);
       /* Ensure that the values just loaded are not changed by
 	 fix-up operations. */
       return 1;
     case 023:     /* fbld m80dec */
       clear_C1();
-      loaded_tag = FPU_load_bcd((u_char *)data_address);
+      loaded_tag = FPU_load_bcd(data_address);
       FPU_settag0(loaded_tag);
       break;
     case 024:     /* fldcw */
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_READ, data_address, 2);
-      FPU_get_user(control_word, (u16 *) data_address);
+      FPU_get_user(control_word, data_address, 2);
       RE_ENTRANT_CHECK_ON;
       if ( partial_status & ~control_word & CW_Exceptions )
 	partial_status |= (SW_Summary | SW_Backward);
@@ -223,47 +223,47 @@
       return 1;
     case 025:      /* fld m80real */
       clear_C1();
-      loaded_tag = FPU_load_extended((long double *)data_address, 0);
+      loaded_tag = FPU_load_extended(data_address, 0);
       FPU_settag0(loaded_tag);
       break;
     case 027:      /* fild m64int */
       clear_C1();
-      loaded_tag = FPU_load_int64((s64 *)data_address);
+      loaded_tag = FPU_load_int64(data_address);
       FPU_settag0(loaded_tag);
       break;
     case 030:     /* fstenv  m14/28byte */
-      fstenv(addr_modes, (u_char *)data_address);
+      fstenv(addr_modes, data_address);
       return 1;
     case 032:      /* fsave */
-      fsave(addr_modes, (u_char *)data_address);
+      fsave(addr_modes, data_address);
       return 1;
     case 033:      /* fbstp m80dec */
       clear_C1();
-      if ( FPU_store_bcd(st0_ptr, st0_tag, (u_char *)data_address) )
+      if ( FPU_store_bcd(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
     case 034:      /* fstcw m16int */
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_WRITE,data_address,2);
-      FPU_put_user(control_word, (u16 *) data_address);
+      FPU_put_user(control_word, data_address, 2);
       RE_ENTRANT_CHECK_ON;
       return 1;
     case 035:      /* fstp m80real */
       clear_C1();
-      if ( FPU_store_extended(st0_ptr, st0_tag, (long double *)data_address) )
+      if ( FPU_store_extended(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
     case 036:      /* fstsw m2byte */
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_WRITE,data_address,2);
-      FPU_put_user(status_word(),(u16 *) data_address);
+      FPU_put_user(status_word(),data_address, 2);
       RE_ENTRANT_CHECK_ON;
       return 1;
     case 037:      /* fistp m64int */
       clear_C1();
-      if ( FPU_store_int64(st0_ptr, st0_tag, (s64 *)data_address) )
+      if ( FPU_store_int64(st0_ptr, st0_tag, data_address) )
 	pop_0();  /* pop only if the number was actually stored
 		     (see the 80486 manual p16-28) */
       break;
Index: fpu/reg_ld_str.c
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/reg_ld_str.c,v
retrieving revision 1.12
diff -u -r1.12 reg_ld_str.c
--- fpu/reg_ld_str.c	15 May 2003 16:19:39 -0000	1.12
+++ fpu/reg_ld_str.c	9 Jun 2003 01:34:29 -0000
@@ -88,15 +88,15 @@
 
 /* Get a long double from user memory */
 int  BX_CPP_AttrRegparmN(2)
-FPU_load_extended(long double *s, int stnr)
+FPU_load_extended(bx_address s, int stnr)
 {
   FPU_REG *sti_ptr = &st(stnr);
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_READ, s, 10);
-  FPU_get_user(sti_ptr->sigl, (u32*)(((u8*)s)+0));
-  FPU_get_user(sti_ptr->sigh, (u32*)(((u8*)s)+4));
-  FPU_get_user(sti_ptr->exp,  (u16*)(((u8*)s)+8));
+  FPU_get_user(sti_ptr->sigl, s+0, 4);
+  FPU_get_user(sti_ptr->sigh, s+4, 4);
+  FPU_get_user(sti_ptr->exp,  s+8, 2);
   RE_ENTRANT_CHECK_ON;
 
   return FPU_tagof(sti_ptr);
@@ -105,15 +105,15 @@
 
 /* Get a double from user memory */
 int  BX_CPP_AttrRegparmN(2)
-FPU_load_double(double *dfloat, FPU_REG *loaded_data)
+FPU_load_double(bx_address dfloat, FPU_REG *loaded_data)
 {
   int exp, tag, negative;
   u32 m64, l64;
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_READ, dfloat, 8);
-  FPU_get_user(m64, 1 + (u32 *) dfloat);
-  FPU_get_user(l64, (u32 *) dfloat);
+  FPU_get_user(m64, dfloat+4, 4);
+  FPU_get_user(l64, dfloat,   4);
   RE_ENTRANT_CHECK_ON;
 
   negative = (m64 & 0x80000000) ? SIGN_Negative : SIGN_Positive;
@@ -178,14 +178,14 @@
 
 /* Get a float from user memory */
 int  BX_CPP_AttrRegparmN(2)
-FPU_load_single(float *single, FPU_REG *loaded_data)
+FPU_load_single(bx_address single, FPU_REG *loaded_data)
 {
   u32 m32;
   int exp, tag, negative;
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_READ, single, 4);
-  FPU_get_user(m32, (u32 *) single);
+  FPU_get_user(m32, single, 4);
   RE_ENTRANT_CHECK_ON;
 
   negative = (m32 & 0x80000000) ? SIGN_Negative : SIGN_Positive;
@@ -243,7 +243,7 @@
 
 /* Get a 64bit quantity from user memory */
 int  BX_CPP_AttrRegparmN(1)
-FPU_load_int64(s64 *_s)
+FPU_load_int64(bx_address _s)
 {
   s64 s;
   int sign;
@@ -253,8 +253,8 @@
   FPU_verify_area(VERIFY_READ, _s, 8);
   {
   u32 chunk0, chunk1;
-  FPU_get_user(chunk0, (u32*)(((u8*)_s)+0));
-  FPU_get_user(chunk1, (u32*)(((u8*)_s)+4));
+  FPU_get_user(chunk0, _s+0, 4);
+  FPU_get_user(chunk1, _s+4, 4);
   s = chunk0;
   s |= (((u64)chunk1) << 32);
   }
@@ -282,14 +282,14 @@
 
 /* Get a long from user memory */
 int  BX_CPP_AttrRegparmN(2)
-FPU_load_int32(s32 *_s, FPU_REG *loaded_data)
+FPU_load_int32(bx_address _s, FPU_REG *loaded_data)
 {
   s32 s;
   int negative;
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_READ, _s, 4);
-  FPU_get_user(s, _s);
+  FPU_get_user(s, _s, 4);
   RE_ENTRANT_CHECK_ON;
 
   if (s == 0)
@@ -312,14 +312,14 @@
 
 /* Get a short from user memory */
 int  BX_CPP_AttrRegparmN(1)
-FPU_load_int16(s16 *_s, FPU_REG *loaded_data)
+FPU_load_int16(bx_address _s, FPU_REG *loaded_data)
 {
   s16 s, negative;
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_READ, _s, 2);
   /* Cast as short to get the sign extended. */
-  FPU_get_user(s, _s);
+  FPU_get_user(s, _s, 2);
   RE_ENTRANT_CHECK_ON;
 
   if (s == 0)
@@ -342,7 +342,7 @@
 
 /* Get a packed bcd array from user memory */
 int  BX_CPP_AttrRegparmN(1)
-FPU_load_bcd(u_char *s)
+FPU_load_bcd(bx_address s)
 {
   FPU_REG *st0_ptr = &st(0);
   int pos;
@@ -357,7 +357,7 @@
     {
       l *= 10;
       RE_ENTRANT_CHECK_OFF;
-      FPU_get_user(bcd, (u_char *) s+pos);
+      FPU_get_user(bcd, s+pos, 1);
       RE_ENTRANT_CHECK_ON;
       l += bcd >> 4;
       l *= 10;
@@ -365,7 +365,7 @@
     }
  
   RE_ENTRANT_CHECK_OFF;
-  FPU_get_user(sign, (u_char *) s+9);
+  FPU_get_user(sign, s+9, 1);
   sign = sign & 0x80 ? SIGN_Negative : SIGN_Positive;
   RE_ENTRANT_CHECK_ON;
 
@@ -386,7 +386,7 @@
 
 /* Put a long double into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag, long double *d)
+FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag, bx_address d)
 {
   /*
     The only exception raised by an attempt to store to an
@@ -399,9 +399,9 @@
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_WRITE, d, 10);
 
-      FPU_put_user(st0_ptr->sigl, (u32 *) d);
-      FPU_put_user(st0_ptr->sigh, (u32 *) ((u_char *)d + 4));
-      FPU_put_user(exponent16(st0_ptr), (u16 *) ((u_char *)d + 8));
+      FPU_put_user(st0_ptr->sigl, d, 4);
+      FPU_put_user(st0_ptr->sigh, d + 4, 4);
+      FPU_put_user(exponent16(st0_ptr), d + 8, 2);
       RE_ENTRANT_CHECK_ON;
 
       return 1;
@@ -415,9 +415,9 @@
       /* Put out the QNaN indefinite */
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_WRITE,d,10);
-      FPU_put_user(0, (u32 *) d);
-      FPU_put_user(0xc0000000, 1 + (u32 *) d);
-      FPU_put_user(0xffff, 4 + (s16 *) d);
+      FPU_put_user(0,          d, 4);
+      FPU_put_user(0xc0000000, d + 4, 4);
+      FPU_put_user(0xffff,     d + 8, 2);
       RE_ENTRANT_CHECK_ON;
       return 1;
     }
@@ -428,7 +428,7 @@
 
 /* Put a double into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double *dfloat)
+FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, bx_address dfloat)
 {
   u32 l[2];
   u32 increment = 0;	/* avoid gcc warnings */
@@ -644,9 +644,9 @@
 	  /* The masked response */
 	  /* Put out the QNaN indefinite */
 	  RE_ENTRANT_CHECK_OFF;
-	  FPU_verify_area(VERIFY_WRITE,(void *)dfloat,8);
-	  FPU_put_user(0, (u32 *) dfloat);
-	  FPU_put_user(0xfff80000, 1 + (u32 *) dfloat);
+	  FPU_verify_area(VERIFY_WRITE,dfloat,8);
+	  FPU_put_user(0,          dfloat,   4);
+	  FPU_put_user(0xfff80000, dfloat+4, 4);
 	  RE_ENTRANT_CHECK_ON;
 	  return 1;
 	}
@@ -657,9 +657,9 @@
     l[1] |= 0x80000000;
 
   RE_ENTRANT_CHECK_OFF;
-  FPU_verify_area(VERIFY_WRITE,(void *)dfloat,8);
-  FPU_put_user(l[0], (u32 *)dfloat);
-  FPU_put_user(l[1], 1 + (u32 *)dfloat);
+  FPU_verify_area(VERIFY_WRITE,dfloat,8);
+  FPU_put_user(l[0], dfloat,   4);
+  FPU_put_user(l[1], dfloat+4, 4);
   RE_ENTRANT_CHECK_ON;
 
   return 1;
@@ -668,7 +668,7 @@
 
 /* Put a float into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float *single)
+FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, bx_address single)
 {
   s32 templ;
   u32 increment = 0;     	/* avoid gcc warnings */
@@ -872,8 +872,8 @@
 	  /* The masked response */
 	  /* Put out the QNaN indefinite */
 	  RE_ENTRANT_CHECK_OFF;
-	  FPU_verify_area(VERIFY_WRITE,(void *)single,4);
-	  FPU_put_user(0xffc00000, (u32 *) single);
+	  FPU_verify_area(VERIFY_WRITE,single,4);
+	  FPU_put_user(0xffc00000, single, 4);
 	  RE_ENTRANT_CHECK_ON;
 	  return 1;
 	}
@@ -891,8 +891,8 @@
     templ |= 0x80000000;
 
   RE_ENTRANT_CHECK_OFF;
-  FPU_verify_area(VERIFY_WRITE,(void *)single,4);
-  FPU_put_user(templ,(u32 *) single);
+  FPU_verify_area(VERIFY_WRITE,single,4);
+  FPU_put_user(templ,single, 4);
   RE_ENTRANT_CHECK_ON;
 
   return 1;
@@ -901,7 +901,7 @@
 
 /* Put a 64bit quantity into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, s64 *d)
+FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, bx_address d)
 {
   FPU_REG t;
   s64 tll;
@@ -958,9 +958,9 @@
     }
 
   RE_ENTRANT_CHECK_OFF;
-  FPU_verify_area(VERIFY_WRITE,(void *)d,8);
-  FPU_put_user((u32) tll,       (u32*)(((u8 *)d)+0));
-  FPU_put_user((u32) (tll>>32), (u32*)(((u8 *)d)+4));
+  FPU_verify_area(VERIFY_WRITE,d,8);
+  FPU_put_user((u32) tll,       d+0, 4);
+  FPU_put_user((u32) (tll>>32), d+4, 4);
   RE_ENTRANT_CHECK_ON;
 
   return 1;
@@ -969,7 +969,7 @@
 
 /* Put a long into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, s32 *d)
+FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, bx_address d)
 {
   FPU_REG t;
   int precision_loss;
@@ -1018,7 +1018,7 @@
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_WRITE,d,4);
-  FPU_put_user(t.sigl, (u32 *) d);
+  FPU_put_user(t.sigl, d, 4);
   RE_ENTRANT_CHECK_ON;
 
   return 1;
@@ -1027,7 +1027,7 @@
 
 /* Put a short into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, s16 *d)
+FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, bx_address d)
 {
   FPU_REG t;
   int precision_loss;
@@ -1076,7 +1076,7 @@
 
   RE_ENTRANT_CHECK_OFF;
   FPU_verify_area(VERIFY_WRITE,d,2);
-  FPU_put_user((s16)t.sigl,(s16 *) d);
+  FPU_put_user((s16)t.sigl,d,2);
   RE_ENTRANT_CHECK_ON;
 
   return 1;
@@ -1085,7 +1085,7 @@
 
 /* Put a packed bcd array into user memory */
 int  BX_CPP_AttrRegparmN(3)
-FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char *d)
+FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, bx_address d)
 {
   FPU_REG t;
   u64 ll;
@@ -1126,11 +1126,11 @@
 	  /* Produce the QNaN "indefinite" */
 	  RE_ENTRANT_CHECK_OFF;
 	  FPU_verify_area(VERIFY_WRITE,d,10);
-	  for (i = 0; i < 7; i++)
-	    FPU_put_user(0, (u_char *) d+i); /* These bytes "undefined" */
-	  FPU_put_user(0xc0, (u_char *) d+7); /* This byte "undefined" */
-	  FPU_put_user(0xff, (u_char *) d+8);
-	  FPU_put_user(0xff, (u_char *) d+9);
+	  for ( i = 0; i < 7; i++)
+	    FPU_put_user(0, d+i,1); /* These bytes "undefined" */
+	  FPU_put_user(0xc0, d+7,1); /* This byte "undefined" */
+	  FPU_put_user(0xff, d+8,1);
+	  FPU_put_user(0xff, d+9,1);
 	  RE_ENTRANT_CHECK_ON;
 	  return 1;
 	}
@@ -1151,11 +1151,11 @@
       b = FPU_div_small(&ll, 10);
       b |= (FPU_div_small(&ll, 10)) << 4;
       RE_ENTRANT_CHECK_OFF;
-      FPU_put_user(b,(u_char *) d+i);
+      FPU_put_user(b,d+i,1);
       RE_ENTRANT_CHECK_ON;
     }
   RE_ENTRANT_CHECK_OFF;
-  FPU_put_user(sign,(u_char *) d+9);
+  FPU_put_user(sign,d+9,1);
   RE_ENTRANT_CHECK_ON;
 
   return 1;
@@ -1236,8 +1236,8 @@
 
 /*===========================================================================*/
 
-u_char  BX_CPP_AttrRegparmN(2)
-*fldenv(fpu_addr_modes addr_modes, u_char *s)
+bx_address  BX_CPP_AttrRegparmN(2)
+fldenv(fpu_addr_modes addr_modes, bx_address s)
 {
   u16 tag_word = 0;
   u_char tag;
@@ -1249,13 +1249,13 @@
     {
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_READ, s, 0x0e);
-      FPU_get_user(control_word, (u16 *) s);
-      FPU_get_user(partial_status, (u16 *) (s+2));
-      FPU_get_user(tag_word, (u16 *) (s+4));
-      FPU_get_user(instruction_address.offset, (u16 *) (s+6));
-      FPU_get_user(instruction_address.selector, (u16 *) (s+8));
-      FPU_get_user(operand_address.offset, (u16 *) (s+0x0a));
-      FPU_get_user(operand_address.selector, (u16 *) (s+0x0c));
+      FPU_get_user(control_word, s, 2);
+      FPU_get_user(partial_status, (s+2), 2);
+      FPU_get_user(tag_word, (s+4), 2);
+      FPU_get_user(instruction_address.offset, (s+6), 2);
+      FPU_get_user(instruction_address.selector, (s+8), 2);
+      FPU_get_user(operand_address.offset, (s+0x0a), 2);
+      FPU_get_user(operand_address.selector, (s+0x0c), 2);
       RE_ENTRANT_CHECK_ON;
       s += 0x0e;
       if (addr_modes.default_mode == VM86)
@@ -1269,14 +1269,14 @@
     {
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_READ, s, 0x1c);
-      FPU_get_user(control_word, (u16 *) s);
-      FPU_get_user(partial_status, (u16 *) (s+4));
-      FPU_get_user(tag_word, (u16 *) (s+8));
-      FPU_get_user(instruction_address.offset, (u32 *) (s+0x0c));
-      FPU_get_user(instruction_address.selector, (u16 *) (s+0x10));
-      FPU_get_user(instruction_address.opcode, (u16 *) (s+0x12));
-      FPU_get_user(operand_address.offset, (u32 *) (s+0x14));
-      FPU_get_user(operand_address.selector, (u32 *) (s+0x18));
+      FPU_get_user(control_word, s, 2);
+      FPU_get_user(partial_status, (s+4), 2);
+      FPU_get_user(tag_word, (s+8), 2);
+      FPU_get_user(instruction_address.offset, (s+0x0c), 4);
+      FPU_get_user(instruction_address.selector, (s+0x10), 2);
+      FPU_get_user(instruction_address.opcode, (s+0x12), 2);
+      FPU_get_user(operand_address.offset, (s+0x14), 4);
+      FPU_get_user(operand_address.selector, (s+0x18), 4);
       RE_ENTRANT_CHECK_ON;
       s += 0x1c;
     }
@@ -1329,10 +1329,10 @@
 
 
 void  BX_CPP_AttrRegparmN(2)
-frstor(fpu_addr_modes addr_modes, u_char *data_address)
+frstor(fpu_addr_modes addr_modes, bx_address data_address)
 {
   int i, regnr;
-  u_char *s = fldenv(addr_modes, data_address);
+  bx_address s = fldenv(addr_modes, data_address);
   int offset = (top & 7) * sizeof(FPU_REG), other = 8*sizeof(FPU_REG) - offset;
 
   /* Copy all registers in stack order. */
@@ -1343,18 +1343,18 @@
 
   fpu_reg_p = (FPU_REG *) (register_base+offset);
   while (other>0) {
-    FPU_get_user(fpu_reg_p->sigl, (u32*)(s+0));
-    FPU_get_user(fpu_reg_p->sigh, (u32*)(s+4));
-    FPU_get_user(fpu_reg_p->exp,  (u16*)(s+8));
+    FPU_get_user(fpu_reg_p->sigl, (s+0), 4);
+    FPU_get_user(fpu_reg_p->sigh, (s+4), 4);
+    FPU_get_user(fpu_reg_p->exp,  (s+8), 2);
     fpu_reg_p++;
     s += 10;
     other -= sizeof(FPU_REG);
     }
   fpu_reg_p = (FPU_REG *) register_base;
   while (offset>0) {
-    FPU_get_user(fpu_reg_p->sigl, (u32*)(s+0));
-    FPU_get_user(fpu_reg_p->sigh, (u32*)(s+4));
-    FPU_get_user(fpu_reg_p->exp,  (u16*)(s+8));
+    FPU_get_user(fpu_reg_p->sigl, (s+0), 4);
+    FPU_get_user(fpu_reg_p->sigh, (s+4), 4);
+    FPU_get_user(fpu_reg_p->exp,  (s+8), 2);
     fpu_reg_p++;
     s += 10;
     offset -= sizeof(FPU_REG);
@@ -1373,8 +1373,8 @@
 }
 
 
-u_char  BX_CPP_AttrRegparmN(2)
-*fstenv(fpu_addr_modes addr_modes, u_char *d)
+bx_address  BX_CPP_AttrRegparmN(2)
+fstenv(fpu_addr_modes addr_modes, bx_address d)
 {
   if ((addr_modes.default_mode == VM86) ||
       ((addr_modes.default_mode == PM16)
@@ -1383,25 +1383,25 @@
       RE_ENTRANT_CHECK_OFF;
       FPU_verify_area(VERIFY_WRITE,d,14);
 #ifdef PECULIAR_486
-      FPU_put_user(control_word & ~0xe080, (u32 *) d);
+      FPU_put_user(control_word & ~0xe080, d, 4);
 #else
-      FPU_put_user(control_word, (u16 *) d);
+      FPU_put_user(control_word, d,2);
 #endif /* PECULIAR_486 */
-      FPU_put_user(status_word(), (u16 *) (d+2));
-      FPU_put_user(fpu_tag_word, (u16 *) (d+4));
-      FPU_put_user(instruction_address.offset, (u16 *) (d+6));
-      FPU_put_user(operand_address.offset, (u16 *) (d+0x0a));
+      FPU_put_user(status_word(), (d+2), 2);
+      FPU_put_user(fpu_tag_word,  (d+4), 2);
+      FPU_put_user(instruction_address.offset, (d+6), 2);
+      FPU_put_user(operand_address.offset, (d+0x0a), 2);
       if (addr_modes.default_mode == VM86)
 	{
 	  FPU_put_user((instruction_address.offset & 0xf0000) >> 4,
-		      (u16 *) (d+8));
+		      (d+8), 2);
 	  FPU_put_user((operand_address.offset & 0xf0000) >> 4,
-		      (u16 *) (d+0x0c));
+		      (d+0x0c), 2);
 	}
       else
 	{
-	  FPU_put_user(instruction_address.selector, (u16 *) (d+8));
-	  FPU_put_user(operand_address.selector, (u16 *) (d+0x0c));
+	  FPU_put_user(instruction_address.selector, (d+8), 2);
+	  FPU_put_user(operand_address.selector, (d+0x0c), 2);
 	}
       RE_ENTRANT_CHECK_ON;
       d += 0x0e;
@@ -1419,17 +1419,17 @@
       i387.fcs &= ~0xf8000000;
       i387.fos |= 0xffff0000;
 #endif /* PECULIAR_486 */
-      FPU_put_user((u32) i387.cwd, (u32*)(((u8 *)d)+0));
-      FPU_put_user((u32) i387.swd, (u32*)(((u8 *)d)+4));
-      FPU_put_user((u32) i387.twd, (u32*)(((u8 *)d)+8));
-      FPU_put_user((u32) i387.fip, (u32*)(((u8 *)d)+12));
-      FPU_put_user((u32) i387.fcs, (u32*)(((u8 *)d)+16));
-      FPU_put_user((u32) i387.foo, (u32*)(((u8 *)d)+20));
-      FPU_put_user((u32) i387.fos, (u32*)(((u8 *)d)+24));
+      FPU_put_user((u32) i387.cwd, d+0, 4);
+      FPU_put_user((u32) i387.swd, d+4, 4);
+      FPU_put_user((u32) i387.twd, d+8, 4);
+      FPU_put_user((u32) i387.fip, d+12, 4);
+      FPU_put_user((u32) i387.fcs, d+16, 4);
+      FPU_put_user((u32) i387.foo, d+20, 4);
+      FPU_put_user((u32) i387.fos, d+24, 4);
       RE_ENTRANT_CHECK_ON;
       d += 0x1c;
     }
-  
+
   control_word |= CW_Exceptions;
   partial_status &= ~(SW_Summary | SW_Backward);
 
@@ -1438,9 +1438,9 @@
 
 
 void  BX_CPP_AttrRegparmN(2)
-fsave(fpu_addr_modes addr_modes, u_char *data_address)
+fsave(fpu_addr_modes addr_modes, bx_address data_address)
 {
-  u_char *d;
+  bx_address d;
   int offset = (top & 7) * sizeof(FPU_REG), other = 8*sizeof(FPU_REG) - offset;
 
   d = fstenv(addr_modes, data_address);
@@ -1454,18 +1454,18 @@
 
   fpu_reg_p = (FPU_REG *) (register_base+offset);
   while (other>0) {
-    FPU_put_user(fpu_reg_p->sigl, (u32*)(d+0));
-    FPU_put_user(fpu_reg_p->sigh, (u32*)(d+4));
-    FPU_put_user(fpu_reg_p->exp,  (u16*)(d+8));
+    FPU_put_user(fpu_reg_p->sigl, (d+0), 4);
+    FPU_put_user(fpu_reg_p->sigh, (d+4), 4);
+    FPU_put_user(fpu_reg_p->exp,  (d+8), 2);
     fpu_reg_p++;
     d += 10;
     other -= sizeof(FPU_REG);
     }
   fpu_reg_p = (FPU_REG *) register_base;
   while (offset>0) {
-    FPU_put_user(fpu_reg_p->sigl, (u32*)(d+0));
-    FPU_put_user(fpu_reg_p->sigh, (u32*)(d+4));
-    FPU_put_user(fpu_reg_p->exp,  (u16*)(d+8));
+    FPU_put_user(fpu_reg_p->sigl, (d+0), 4);
+    FPU_put_user(fpu_reg_p->sigh, (d+4), 4);
+    FPU_put_user(fpu_reg_p->exp,  (d+8), 2);
     fpu_reg_p++;
     d += 10;
     offset -= sizeof(FPU_REG);
Index: fpu/wmFPUemu_glue.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/wmFPUemu_glue.cc,v
retrieving revision 1.21
diff -u -r1.21 wmFPUemu_glue.cc
--- fpu/wmFPUemu_glue.cc	22 Apr 2003 20:21:34 -0000	1.21
+++ fpu/wmFPUemu_glue.cc	9 Jun 2003 01:34:29 -0000
@@ -58,7 +58,7 @@
 math_emulate(fpu_addr_modes addr_modes,
               u_char  FPU_modrm,
               u_char byte1,
-              void *data_address,
+              bx_address data_address,
               struct address data_sel_off,
               struct address entry_sel_off);
 
@@ -77,7 +77,7 @@
 BX_CPU_C::fpu_execute(bxInstruction_c *i)
 {
   fpu_addr_modes addr_modes;
-  void *data_address;
+  bx_address data_address;
   struct address data_sel_off;
   struct address entry_sel_off;
   bx_bool is_32;
@@ -125,7 +125,7 @@
   entry_sel_off.selector = BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value;
 
 // should set these fields to 0 if mem operand not used
-  data_address = (void *) RMAddr(i);
+  data_address = RMAddr(i);
   data_sel_off.offset = RMAddr(i);
   data_sel_off.selector = BX_CPU_THIS_PTR sregs[i->seg()].selector.value;
 
@@ -183,17 +183,17 @@
 }
 
   void BX_CPP_AttrRegparmN(3)
-fpu_verify_area(unsigned what, void *ptr, unsigned n)
+fpu_verify_area(unsigned what, bx_address ptr, unsigned n)
 {
   bx_segment_reg_t *seg;
 
   seg = &fpu_cpu_ptr->sregs[fpu_iptr->seg()];
 
   if (what == VERIFY_READ) {
-    fpu_cpu_ptr->read_virtual_checks(seg, PTR2INT(ptr), n);
+    fpu_cpu_ptr->read_virtual_checks(seg, ptr, n);
     }
   else {  // VERIFY_WRITE
-    fpu_cpu_ptr->write_virtual_checks(seg, PTR2INT(ptr), n);
+    fpu_cpu_ptr->write_virtual_checks(seg, ptr, n);
     }
 }
 
@@ -206,7 +206,7 @@
 
 
   unsigned BX_CPP_AttrRegparmN(2)
-fpu_get_user(void *ptr, unsigned len)
+fpu_get_user(bx_address ptr, unsigned len)
 {
   Bit32u val32;
   Bit16u val16;
@@ -214,15 +214,15 @@
 
   switch (len) {
     case 1:
-      fpu_cpu_ptr->read_virtual_byte(fpu_iptr->seg(), PTR2INT(ptr), &val8);
+      fpu_cpu_ptr->read_virtual_byte(fpu_iptr->seg(), ptr, &val8);
       val32 = val8;
       break;
     case 2:
-      fpu_cpu_ptr->read_virtual_word(fpu_iptr->seg(), PTR2INT(ptr), &val16);
+      fpu_cpu_ptr->read_virtual_word(fpu_iptr->seg(), ptr, &val16);
       val32 = val16;
       break;
     case 4:
-      fpu_cpu_ptr->read_virtual_dword(fpu_iptr->seg(), PTR2INT(ptr), &val32);
+      fpu_cpu_ptr->read_virtual_dword(fpu_iptr->seg(), ptr, &val32);
       break;
     default:
       BX_PANIC(("fpu_get_user: len=%u", len));
@@ -231,7 +231,7 @@
 }
 
   void BX_CPP_AttrRegparmN(2)
-fpu_put_user(unsigned val, void *ptr, unsigned len)
+fpu_put_user(unsigned val, bx_address ptr, unsigned len)
 {
   Bit32u val32;
   Bit16u val16;
@@ -240,15 +240,15 @@
   switch (len) {
     case 1:
       val8 = val;
-      fpu_cpu_ptr->write_virtual_byte(fpu_iptr->seg(), PTR2INT(ptr), &val8);
+      fpu_cpu_ptr->write_virtual_byte(fpu_iptr->seg(), ptr, &val8);
       break;
     case 2:
       val16 = val;
-      fpu_cpu_ptr->write_virtual_word(fpu_iptr->seg(), PTR2INT(ptr), &val16);
+      fpu_cpu_ptr->write_virtual_word(fpu_iptr->seg(), ptr, &val16);
       break;
     case 4:
       val32 = val;
-      fpu_cpu_ptr->write_virtual_dword(fpu_iptr->seg(), PTR2INT(ptr), &val32);
+      fpu_cpu_ptr->write_virtual_dword(fpu_iptr->seg(), ptr, &val32);
       break;
     default:
       BX_PANIC(("fpu_put_user: len=%u", len));
