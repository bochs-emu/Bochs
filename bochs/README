BRANCH_PLUGINS

This branch is a place to experiment with Bochs plugins.  Bryce created
the branch on October 4, 2002 and checked in patch.plugins3 with
minor changes to get it to compile.  Plugins3 was a patch from 
December 2001 that copied in some of the plugin architecture from
plex86.  Here are the comments from that patch:

> Patch name: patch.plugins3
> Author: Bryce Denney
> Date: Wed Dec 12 17:56:11 EST 2001
> 
> This patch replaces the Bochs keyboard with a slightly modified version
> of the plex86 keyboard device, which is implemented as a plugin.  This
> is sort of a proof of concept, rather than anything that I'm about to
> check in.  It uses GNU libtool to compile the plex86 keyboard code into
> a shared library, and installs that shared library in
> /tmp/bochslib/libplex-keyboard.so.  Then the new code in plugin.cc (which
> is adapted from the plex86 plugin code) loads the libplex-keyboard library
> during initialization and installs the plex86 keyboard instead of the
> bochs keyboard.
> 
> I chose the keyboard because it takes about 2 seconds to test that it's
> basically working, and because the bochs and plex86 implementations hadn't
> changed very much since they split.
> 
> If you look at plex-keyboard.cc and plex-keyboard.h, it is fundamentally the
> same as the current plex86 code.  I have changed lots of names from bx_* to
> plex_* just to reduce confusion and mayhem when I was compiling with both
> kbd implementations.  I didn't change anything except to get it to compile.

plugins5 is based on plugins3, with the following changes :
 - plex86 keyboard device was marged with Bochs keyboard, as a plugin
 - plugin.cc was cleaned up
 - a device registration mechanism was set up
 - the biosdev and unmapped device were plugin-ized

The branch is called BRANCH_PLUGINS.  There is a normal tag called
BRANCH_PLUGINS_BASE that marks the point where the branch began.  This
will help at merge time.

TO DO:
- wxWindows gui as a plugin will not start up.  Normally wxWindows
  takes over your main() function and inserts its own app init code.
  We'll have to figure out what that app init code does and put it
  in plugin_init.
- Bryce is experimenting with using classes with virtual functions
  to make the plugin interface cleaner.  The keyboard plugin has been
  implemented this way, and all the gui modules are implemented in a
  very similar way.
- convert remaining devices

- platform specific issues
  - make sure LTDL works on VC++
  - to support plugins on win32, we must add special tags on any function or
    class in the executable that the plugins need to know about.  See
    plugin-test code for examples, e.g. definition of MAINAPI in
    bochs-testing/plugin-test/test8-execlass/main.h.
  - to support plugins on MacOSX, we must ensure that no plugins have
    any global symbol names in common, including plugin_init!  An
    easy solution to this is to say that all plugin functions which can
    be looked up with dlsym must follow a pattern like "%s_BXPLUG_%s",
    where the first %s is the module name and the second is the plain
    symbol name, e.g. pic_BXPLUG_plugin_init.  Symbols that are used 
    internally can be declared static (file scope only).
  - to support plugins on MacOSX, the user must install dlcompat.  Otherwise
    libtool's configure script will discovert that no dlopen() or equivalent
    function is found, and it will not be able to build/load plugins.
    The configure script should bomb in this case, with an error that says
    where to find dlcompat.  dlcompat IS installed on SF compile farm in
    /sw/include and /sw/lib.
  - to support plugins on Solaris, we must not rely on the use of
    global object constructors.  In fact every global variable in a module
    MUST BE set to a compile-time constant.  We must declare object pointers
    as globals, not actual objects.

- configure script work
  - LTDL has a feature called dlpreload which sort of emulates dlopen
    by linking all the modules statically and then emulating dlopen calls.
    I don't see any value in this for plugins.  If the platform cannot
    support dlopen or some equivalent, let the configure script crash and
    tell the user to configure without plugins instead.
  - Now we can compile multiple guis and devices, when before we had
    to choose just one.  So now we need a few configure lines to decide
    whether to compile each optional or platform specific plugin.
    Basically, we should be able compile everything that CAN compile on a
    platform.  A decent amount of configure script work will be required
    to build a list of which plugins we think CAN be compiled.


- how do we know what plugins should be available when we start Bochs?
  - we can have required plugins, optional plugins, and user plugins.
    - (V2.0) For the required plugins, Bochs will assume they are available and
      panic if they are not.  A required plugin will always be loaded when
      Bochs starts up.  In the bochsrc we can provide a way for the user to
      REPLACE a required plugin with a different plugin that implements the
      same C++ interface, but there is no way to ask bochs to NOT load a
      required plugin.  I'm not sure how to configure the replacement
      plugin--this may have to be added later.  Bochsrc line: 
        replace_required_plugin: old=pic, new=mypic
    - (V2.0) Optional plugins are plugins that Bochs knows about at compile
      time.  Any information needed to configure the plugin is compiled into
      the Bochs binary, so the device can be configured even before loading the
      plugin.  Then, when we initialize hardware, if the device is enabled then
      the plugin will actually be loaded.  Bochs will panic if an optional
      plugin cannot be loaded.
    - (Later?) A user plugin is one that Bochs does NOT know about at compile
      time.  In order to configure it, the user must first ask Bochs to load
      it, either with a bochsrc line like 'plugin_load: NAME', or through the
      configuration interface.  Once the plugin is loaded, Bochs can figure out
      how to configure the device and display a menu or dialog so that the user
      can edit its options.  We will need to dream up some kind of bochsrc
      syntax so that you can pass parameters to the plugin as well.  User
      plugins may not be supported until after v2.0.
  - some devices, such as the GUI, PIT, SB, and NE2000, have several different
    possible implementations.  In this case, all implementations should be
    children of a single stub class which produces errors or panics if it
    is called, depending on the importance of the device.  There is always
    one instance of the stub class lying around, which will be used if none of
    the implementation plugins is loaded.  Either an optional plugin or a
    user plugin can fill in these slots.
  - make a list of plugins sorted into categories.
    - required plugins
      - pic
      - cmos
      - dma
      - unmapped
      - keyboard: because it has 6 functions that are reference by other
        modules.
    - optional: serial, parallel, floppy, vga, biosdev, cmos, harddrv
  - add plugin load code as the module is needed.

- how do we locate plugins on the disk?
  - fortunately, the LTDL library takes care of searching a list of paths.
  - We can tell people how to set the LTDL_LIBRARY_PATH variable.  
  - we can implement a bochsrc command like
      plugin_search_directory: /path/to/libs
    which would call lt_dlsetsearchpath() to add the path to LTDL's list of
    directories it will search.

- (assigned to Bryce) how does the user select which gui to use?  Add a bochsrc
  parameter "gui_select: sdl".  This variable can also be edited in
  configuration menus.  If there is no user-specified value when it's time to
  initialize the gui, it will choose the first gui in the list of available
  ones.  We just need to put the list in a reasonable order, for example don't 
  put nogui first.

- parameters of plugins... It would be nice to move the creation of the
  parameters into the code for the device that they affect.  However this
  would mean that you could not configure any plugin (except for whether to
  enable it or not) until you have loaded it.  I don't really want to display a
  dialog that says "Enable this device? [ ]" and load the plugin and fill in
  the rest of the dialog only if they check the box.
  - one solution, which I'm not sure that I like: separate the plugin into
    two shared objects. libDEVNAME_param that sets up the configuration
    parameters only, and libDEVNAME implements the whole thing.  The idea would
    be that you would load EVERY lib*_param on startup so that you can allow
    the user to configure the plugin.  Then only the ones that are enabled
    would load the remainder of their code.
  - alternative: distinguish between plugins known at compile time, and plugins
    which the user adds manually through the config interface or bochsrc.
    For standard plugins that are compiled in, we can put all the parameter
    code into the executable as it is now.  For plugins that are added
    by the user, there is no doubt about whether to load them or not.  They
    wouldn't have asked for it, if they didn't want to load it!  In that
    case, the config parameters can be initialized as soon as the module 
    is loaded.  Once it is loaded, the config interface can display the
    parameters so that the device can be configured.

- take a look at the code generated by calls to virtual functions, to 
  check if there's huge overhead that I don't know about.
- make plugin CPU???


DONE:
- applied patch.plugins5
- updated makefile dependencies now that plugin.h is in there
- all guis converted to plugins
- 8 I/O devices are converted to plugins
- make the Makefile use libtool to build dynamic libraries
- use libtool's ltdl library to open and read dynamic libraries, since it
  has cross platform support
- the Boolean/bx_bool thing will be resolved in the main branch.  I have
  made patch.replace-Boolean.gz which I will apply later, after the
  plugins branch has been merged.  This become more urgent because it
  caused bug #623152 MacOSX: Triple Exception Booting win95
-----------------------------------------------
random notes:

how to make a gui into a plugin?
virtual functions versus lots of function pointers.
Make bx_gui_c a class with virtual methods to be supplied by the
plugins.  Each gui will be a child class of bx_gui_c which supplies
the required methods.

How will the plugin loader know how to create new objects?
It doesn't.  The .so file has a "global" variable like "bx_cmos"
so the constructor must be called as the module loads.  For any
device that needs to be initialized with new operator, I may need
to add a static method to the class that can call the constructor.

class heirarchy:
 logfunctions
 - bx_devmodel_c
   - bx_keyb_stub_c
     - bx_keyb_c

bx_devmodel_c is an abstract class that defines standard functions that all
devices should define, like init and reset.  Each method is defined as empty
in bx_devmodel_c so that child classes can choose to implement them or not.

bx_keyb_stub_c declares the methods that code outside the keyboard would need
to call, such as mouse_motion, gen_scancode, etc.  It declares these methods
virtual, and provides a minimal definition for each that just does a panic.   A
global variable pluginKeyboard initially points to an instance of
bx_keyb_stub_c so that if you forget/fail to load the load the keyboard plugin,
you will see these panics when the methods are called.

bx_keyb_c is the real keyboard code.  In its constructor, it changes 
pluginKeyboard to point to "this".  This is equivalent to installing all
the plugin callbacks associated with the keyboard.  It also works in
nonplugin code, which is a plus. 


hard drive read_handler.  Right now the read_handler
is a static method so it must get its object pointer from somewhere.
  1) It can get it from global variable bx_hard_drive
  2) The hard drive object can be passed in to it
We've always used #2, so every device has methods that look like this:

  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len);
  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsi

If/when we switch over to using virtual methods, there will no longer be
any problem finding the this pointer.  If we go that route, the this_ptr
can be eliminated.  For now, we must use the this_ptr.  Otherwise we could
never support more than one device of a given type.



------------------------------------------
References

From: Tero Pulkkinen (p150650@zori.cs.tut.fi)
 Subject: Re: undefined reference to `pm virtual table' 
 Newsgroups: gnu.g++.help
 Date: 1996/11/15 


> The compile goes off OK, but I get this error at link time:
>   pm.o(.text+0xa8): undefined reference to `pm virtual table'

This error comes from that the compiler didnt make virtual function
table for object even though there's implemented functions that use
objects of that type(constructor for example). Probably your pm-class
has all implemented member functions *inline* and you still have
(pure) virtual functions inside the class.

The creation point of virtual function table usually (dunno if g++ does that)
is at position of first seen noninline function body of that class.
Now if every of your function is inline, there's no place where compiler
could make virtual function table.

Fix is to move body of for example constructor(any member is fine) to the .cc 
file instead of keeping it in .h-file and linking that .o file to your 
executable.

Other sollution is to remove *all* implementations of functions from header
file. If all functions of a class are pure virtual, there's no need for
virtual function table. (Constructor must set pointer to virtual function
table to the object, so, if you have constructor, you'll need virtual
function table too, even in abstract classes...)

> Can someone help me?  Thanks in advance.

Hope this helps....

------------------------------------------------
Bochs x86 Pentium Emulator
Updated: Wed Mar 27 20:02:41  2002
Version: 1.4

WHAT IS BOCHS?

Bochs is a highly portable open source IA-32 (x86) PC emulator
written in C++, that runs on most popular platforms.  It includes
emulation of the Intel x86 CPU, common I/O devices, and a custom
BIOS.  Currently, bochs can be compiled to emulate a 386, 486 or
Pentium CPU.  Bochs is capable of running most Operating Systems
inside the emulation including Linux, Windows 95, DOS, and 
Windows NT 4.  Bochs was written by Kevin Lawton and is currently 
maintained by the Bochs project at "http://bochs.sourceforge.net".

Bochs can be compiled and used in a variety of modes, some which are
still in development.  The 'typical' use of bochs is to provide
complete x86 PC emulation, including the x86 processor, hardware
devices, and memory.  This allows you to run OS's and software within
the emulator on your workstation, much like you have a machine
inside of a machine.  Bochs will allow you to run Win '95
applications on a Solaris machine with X11, for example.

Bochs is distributed under the GNU LGPL.  See COPYING for details.

GETTING CURRENT SOURCE CODE 

Source code for Bochs is available from the Bochs home page at
http://bochs.sourceforge.net.  You can download the most recent
release, use CVS to get the latest sources, or grab a CVS
snapshot which is updated nightly.  The releases contain the most
stable code, but if you want the very newest features try the
CVS version instead. 

WHERE ARE THE DOCS?

The Bochs documentation has been overhauled, and it is now
distributed in a separate package called bochsdoc-VERSION.tar.gz.
A copy is also online at 
  http://bochs.sf.net/doc/docbook/alldocs.html
For now, the old documentation can still be found at
  http://bochs.sf.net/docs-html

WHERE CAN I GET MORE INFORMATION?  HOW DO I REPORT PROBLEMS?

Both the documentation and the Bochs website have instructions on how 
to join the bochs-developers mailing list, which is the primary
forum for discussion of Bochs.  The main page of the website also
has links to bug reports and feature requests.  You can browse and
add to the content in these areas even if you do not have a (free)
SourceForge account.  We need your feedback so that we know what
parts of Bochs to improve.  

There is a patches section on the web site too, if you have made
some changes to Bochs that you want to share.

HOW CAN I HELP?

If you would like contribute to the Bochs project, a good first step
is to join the bochs-developers mailing list, and read the archive
of recent messages to see what's going on.  

If you are a technical person (can follow hardware specs, can write
C/C++) take a look at the list of open bug reports and feature
requests to see if you are interested in working on any of the
problems that are mentioned in them.  If you check out the CVS
sources, make some changes, and create a patch, one of the
developers will be very happy to apply it for you.  Developers who
frequently submit patches, or who embark on major changes in the
source can get write access to CVS.  Be sure to communicate with the
bochs-developers list to avoid several people working on the same
thing without realizing it.

If you are a Bochs user, not a hardware/C++ guru, there are still
many ways you could help out.  For example:
  - improving win32 binary releases
  - building up a set of useful tools to include in those releases
  - writing/cleaning up documentation
  - testing out Bochs on every imaginable operating system and 
    reporting how it goes.
